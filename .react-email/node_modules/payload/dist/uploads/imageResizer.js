"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, /**
 * For the provided image sizes, handle the resizing and the transforms
 * (format, trim, etc.) of each requested image size and return the result object.
 * This only handles the image sizes. The transforms of the original image
 * are handled in {@link ./generateFileData.ts}.
 *
 * The image will be resized according to the provided
 * resize config. If no image sizes are requested, the resolved data will be empty.
 * For every image that dos not need to be resized, an result object with `null`
 * parameters will be returned.
 *
 * @param resizeConfig - the resize config
 * @returns the result of the resize operation(s)
 */ "default", {
    enumerable: true,
    get: function() {
        return resizeAndTransformImageSizes;
    }
});
const _filetype = require("file-type");
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _sanitizefilename = /*#__PURE__*/ _interop_require_default(require("sanitize-filename"));
const _sharp = /*#__PURE__*/ _interop_require_default(require("sharp"));
const _isNumber = require("../utilities/isNumber");
const _fileExists = /*#__PURE__*/ _interop_require_default(require("./fileExists"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Sanitize the image name and extract the extension from the source image
 *
 * @param sourceImage - the source image
 * @returns the sanitized name and extension
 */ const getSanitizedImageData = (sourceImage)=>{
    const extension = sourceImage.split('.').pop();
    const name = (0, _sanitizefilename.default)(sourceImage.substring(0, sourceImage.lastIndexOf('.')) || sourceImage);
    return {
        name,
        ext: extension
    };
};
/**
 * Create a new image name based on the output image name, the dimensions and
 * the extension.
 *
 * Ignore the fact that duplicate names could happen if the there is one
 * size with `width AND height` and one with only `height OR width`. Because
 * space is expensive, we will reuse the same image for both sizes.
 *
 * @param outputImageName - the sanitized image name
 * @param bufferInfo - the buffer info
 * @param extension - the extension to use
 * @returns the new image name that is not taken
 */ const createImageName = (outputImageName, { height, width }, extension)=>`${outputImageName}-${width}x${height}.${extension}`;
/**
 * Create the result object for the image resize operation based on the
 * provided parameters. If the name is not provided, an empty result object
 * is returned.
 *
 * @param name - the name of the image
 * @param filename - the filename of the image
 * @param width - the width of the image
 * @param height - the height of the image
 * @param filesize - the filesize of the image
 * @param mimeType - the mime type of the image
 * @param sizesToSave - the sizes to save
 * @returns the result object
 */ const createResult = (name, filename = null, width = null, height = null, filesize = null, mimeType = null, sizesToSave = [])=>({
        sizeData: {
            [name]: {
                filename,
                filesize,
                height,
                mimeType,
                width
            }
        },
        sizesToSave
    });
/**
 * Check if the image needs to be resized according to the requested dimensions
 * and the original image size. If the resize options withoutEnlargement or withoutReduction are provided,
 * the image will be resized regardless of the requested dimensions, given that the
 * width or height to be resized is provided.
 *
 * @param resizeConfig - object containing the requested dimensions and resize options
 * @param original - the original image size
 * @returns true if resizing is not needed, false otherwise
 */ const preventResize = ({ height: desiredHeight, width: desiredWidth, withoutEnlargement, withoutReduction }, original)=>{
    // default is to allow reduction
    if (withoutReduction !== undefined) {
        return false // needs resize
        ;
    }
    // default is to prevent enlargement
    if (withoutEnlargement !== undefined) {
        return false // needs resize
        ;
    }
    const isWidthOrHeightNotDefined = !desiredHeight || !desiredWidth;
    if (isWidthOrHeightNotDefined) {
        // If width and height are not defined, it means there is a format conversion
        // and the image needs to be "resized" (transformed).
        return false // needs resize
        ;
    }
    const hasInsufficientWidth = desiredWidth > original.width;
    const hasInsufficientHeight = desiredHeight > original.height;
    if (hasInsufficientWidth && hasInsufficientHeight) {
        // doesn't need resize - prevent enlargement. This should only happen if both width and height are insufficient.
        // if only one dimension is insufficient and the other is sufficient, resizing needs to happen, as the image
        // should be resized to the sufficient dimension.
        return true // do not create a new size
        ;
    }
    return false // needs resize
    ;
};
/**
 * Check if the image should be passed directly to sharp without payload adjusting properties.
 *
 * @param resizeConfig - object containing the requested dimensions and resize options
 * @param original - the original image size
 * @returns true if the image should passed directly to sharp
 */ const applyPayloadAdjustments = ({ fit, height, width, withoutEnlargement, withoutReduction }, original)=>{
    if (fit === 'contain' || fit === 'inside') return false;
    if (!(0, _isNumber.isNumber)(height) && !(0, _isNumber.isNumber)(width)) return false;
    const targetAspectRatio = width / height;
    const originalAspectRatio = original.width / original.height;
    if (originalAspectRatio === targetAspectRatio) return false;
    const skipEnlargement = withoutEnlargement && (original.height < height || original.width < width);
    const skipReduction = withoutReduction && (original.height > height || original.width > width);
    if (skipEnlargement || skipReduction) return false;
    return true;
};
/**
 * Sanitize the resize config. If the resize config has the `withoutReduction`
 * property set to true, the `fit` and `position` properties will be set to `contain`
 * and `top left` respectively.
 *
 * @param resizeConfig - the resize config
 * @returns a sanitized resize config
 */ const sanitizeResizeConfig = (resizeConfig)=>{
    if (resizeConfig.withoutReduction) {
        return {
            ...resizeConfig,
            // Why fit `contain` should also be set to https://github.com/lovell/sharp/issues/3595
            fit: resizeConfig?.fit || 'contain',
            position: resizeConfig?.position || 'left top'
        };
    }
    return resizeConfig;
};
async function resizeAndTransformImageSizes({ config, dimensions, file, mimeType, req, savedFilename, staticPath }) {
    const { imageSizes } = config.upload;
    // Noting to resize here so return as early as possible
    if (!imageSizes) return {
        sizeData: {},
        sizesToSave: []
    };
    const sharpBase = (0, _sharp.default)(file.tempFilePath || file.data).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
    ;
    const results = await Promise.all(imageSizes.map(async (imageResizeConfig)=>{
        imageResizeConfig = sanitizeResizeConfig(imageResizeConfig);
        // This checks if a resize should happen. If not, the resized image will be
        // skipped COMPLETELY and thus will not be included in the resulting images.
        // All further format/trim options will thus be skipped as well.
        if (preventResize(imageResizeConfig, dimensions)) {
            return createResult(imageResizeConfig.name);
        }
        const imageToResize = sharpBase.clone();
        let resized = imageToResize;
        if (req.query?.uploadEdits?.focalPoint && applyPayloadAdjustments(imageResizeConfig, dimensions)) {
            const { height: resizeHeight, width: resizeWidth } = imageResizeConfig;
            const resizeAspectRatio = resizeWidth / resizeHeight;
            const originalAspectRatio = dimensions.width / dimensions.height;
            const prioritizeHeight = resizeAspectRatio < originalAspectRatio;
            // Scale the image up or down to fit the resize dimensions
            const scaledImage = imageToResize.resize({
                height: prioritizeHeight ? resizeHeight : null,
                width: prioritizeHeight ? null : resizeWidth
            });
            const { info: scaledImageInfo } = await scaledImage.toBuffer({
                resolveWithObject: true
            });
            // Focal point adjustments
            const focalPoint = {
                x: (0, _isNumber.isNumber)(req.query.uploadEdits.focalPoint?.x) ? req.query.uploadEdits.focalPoint.x : 50,
                y: (0, _isNumber.isNumber)(req.query.uploadEdits.focalPoint?.y) ? req.query.uploadEdits.focalPoint.y : 50
            };
            const safeResizeWidth = resizeWidth ?? scaledImageInfo.width;
            const maxOffsetX = scaledImageInfo.width - safeResizeWidth;
            const leftFocalEdge = Math.round(scaledImageInfo.width * (focalPoint.x / 100) - safeResizeWidth / 2);
            const safeOffsetX = Math.min(Math.max(0, leftFocalEdge), maxOffsetX);
            const safeResizeHeight = resizeHeight ?? scaledImageInfo.height;
            const maxOffsetY = scaledImageInfo.height - safeResizeHeight;
            const topFocalEdge = Math.round(scaledImageInfo.height * (focalPoint.y / 100) - safeResizeHeight / 2);
            const safeOffsetY = Math.min(Math.max(0, topFocalEdge), maxOffsetY);
            // extract the focal area from the scaled image
            resized = scaledImage.extract({
                height: safeResizeHeight,
                left: safeOffsetX,
                top: safeOffsetY,
                width: safeResizeWidth
            });
        } else {
            resized = imageToResize.resize(imageResizeConfig);
        }
        if (imageResizeConfig.formatOptions) {
            resized = resized.toFormat(imageResizeConfig.formatOptions.format, imageResizeConfig.formatOptions.options);
        }
        if (imageResizeConfig.trimOptions) {
            resized = resized.trim(imageResizeConfig.trimOptions);
        }
        const { data: bufferData, info: bufferInfo } = await resized.toBuffer({
            resolveWithObject: true
        });
        const sanitizedImage = getSanitizedImageData(savedFilename);
        if (req.payloadUploadSizes) {
            req.payloadUploadSizes[imageResizeConfig.name] = bufferData;
        }
        const mimeInfo = await (0, _filetype.fromBuffer)(bufferData);
        const imageNameWithDimensions = createImageName(sanitizedImage.name, bufferInfo, mimeInfo?.ext || sanitizedImage.ext);
        const imagePath = `${staticPath}/${imageNameWithDimensions}`;
        if (await (0, _fileExists.default)(imagePath)) {
            try {
                _fs.default.unlinkSync(imagePath);
            } catch  {
            // Ignore unlink errors
            }
        }
        const { height, size, width } = bufferInfo;
        return createResult(imageResizeConfig.name, imageNameWithDimensions, width, height, size, mimeInfo?.mime || mimeType, [
            {
                buffer: bufferData,
                path: imagePath
            }
        ]);
    }));
    return results.reduce((acc, result)=>{
        Object.assign(acc.sizeData, result.sizeData);
        acc.sizesToSave.push(...result.sizesToSave);
        return acc;
    }, {
        sizeData: {},
        sizesToSave: []
    });
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91cGxvYWRzL2ltYWdlUmVzaXplci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFVwbG9hZGVkRmlsZSB9IGZyb20gJ2V4cHJlc3MtZmlsZXVwbG9hZCdcbmltcG9ydCB0eXBlIHsgT3V0cHV0SW5mbyB9IGZyb20gJ3NoYXJwJ1xuXG5pbXBvcnQgeyBmcm9tQnVmZmVyIH0gZnJvbSAnZmlsZS10eXBlJ1xuaW1wb3J0IGZzIGZyb20gJ2ZzJ1xuaW1wb3J0IHNhbml0aXplIGZyb20gJ3Nhbml0aXplLWZpbGVuYW1lJ1xuaW1wb3J0IHNoYXJwIGZyb20gJ3NoYXJwJ1xuXG5pbXBvcnQgdHlwZSB7IFVwbG9hZEVkaXRzIH0gZnJvbSAnLi4vYWRtaW4vY29tcG9uZW50cy92aWV3cy9jb2xsZWN0aW9ucy9FZGl0L3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBTYW5pdGl6ZWRDb2xsZWN0aW9uQ29uZmlnIH0gZnJvbSAnLi4vY29sbGVjdGlvbnMvY29uZmlnL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBQYXlsb2FkUmVxdWVzdCB9IGZyb20gJy4uL2V4cHJlc3MvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IEZpbGVTaXplLCBGaWxlU2l6ZXMsIEZpbGVUb1NhdmUsIEltYWdlU2l6ZSwgUHJvYmVkSW1hZ2VTaXplIH0gZnJvbSAnLi90eXBlcydcblxuaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNOdW1iZXInXG5pbXBvcnQgZmlsZUV4aXN0cyBmcm9tICcuL2ZpbGVFeGlzdHMnXG5cbnR5cGUgUmVzaXplQXJncyA9IHtcbiAgY29uZmlnOiBTYW5pdGl6ZWRDb2xsZWN0aW9uQ29uZmlnXG4gIGRpbWVuc2lvbnM6IFByb2JlZEltYWdlU2l6ZVxuICBmaWxlOiBVcGxvYWRlZEZpbGVcbiAgbWltZVR5cGU6IHN0cmluZ1xuICByZXE6IFBheWxvYWRSZXF1ZXN0ICYge1xuICAgIHF1ZXJ5Pzoge1xuICAgICAgdXBsb2FkRWRpdHM/OiBVcGxvYWRFZGl0c1xuICAgIH1cbiAgfVxuICBzYXZlZEZpbGVuYW1lOiBzdHJpbmdcbiAgc3RhdGljUGF0aDogc3RyaW5nXG59XG5cbi8qKiBSZXN1bHQgZnJvbSByZXNpemluZyBhbmQgdHJhbnNmb3JtaW5nIHRoZSByZXF1ZXN0ZWQgaW1hZ2Ugc2l6ZXMgKi9cbnR5cGUgSW1hZ2VTaXplc1Jlc3VsdCA9IHtcbiAgc2l6ZURhdGE6IEZpbGVTaXplc1xuICBzaXplc1RvU2F2ZTogRmlsZVRvU2F2ZVtdXG59XG5cbnR5cGUgU2FuaXRpemVkSW1hZ2VEYXRhID0ge1xuICBleHQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSB0aGUgaW1hZ2UgbmFtZSBhbmQgZXh0cmFjdCB0aGUgZXh0ZW5zaW9uIGZyb20gdGhlIHNvdXJjZSBpbWFnZVxuICpcbiAqIEBwYXJhbSBzb3VyY2VJbWFnZSAtIHRoZSBzb3VyY2UgaW1hZ2VcbiAqIEByZXR1cm5zIHRoZSBzYW5pdGl6ZWQgbmFtZSBhbmQgZXh0ZW5zaW9uXG4gKi9cbmNvbnN0IGdldFNhbml0aXplZEltYWdlRGF0YSA9IChzb3VyY2VJbWFnZTogc3RyaW5nKTogU2FuaXRpemVkSW1hZ2VEYXRhID0+IHtcbiAgY29uc3QgZXh0ZW5zaW9uID0gc291cmNlSW1hZ2Uuc3BsaXQoJy4nKS5wb3AoKVxuICBjb25zdCBuYW1lID0gc2FuaXRpemUoc291cmNlSW1hZ2Uuc3Vic3RyaW5nKDAsIHNvdXJjZUltYWdlLmxhc3RJbmRleE9mKCcuJykpIHx8IHNvdXJjZUltYWdlKVxuICByZXR1cm4geyBuYW1lLCBleHQ6IGV4dGVuc2lvbiB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGltYWdlIG5hbWUgYmFzZWQgb24gdGhlIG91dHB1dCBpbWFnZSBuYW1lLCB0aGUgZGltZW5zaW9ucyBhbmRcbiAqIHRoZSBleHRlbnNpb24uXG4gKlxuICogSWdub3JlIHRoZSBmYWN0IHRoYXQgZHVwbGljYXRlIG5hbWVzIGNvdWxkIGhhcHBlbiBpZiB0aGUgdGhlcmUgaXMgb25lXG4gKiBzaXplIHdpdGggYHdpZHRoIEFORCBoZWlnaHRgIGFuZCBvbmUgd2l0aCBvbmx5IGBoZWlnaHQgT1Igd2lkdGhgLiBCZWNhdXNlXG4gKiBzcGFjZSBpcyBleHBlbnNpdmUsIHdlIHdpbGwgcmV1c2UgdGhlIHNhbWUgaW1hZ2UgZm9yIGJvdGggc2l6ZXMuXG4gKlxuICogQHBhcmFtIG91dHB1dEltYWdlTmFtZSAtIHRoZSBzYW5pdGl6ZWQgaW1hZ2UgbmFtZVxuICogQHBhcmFtIGJ1ZmZlckluZm8gLSB0aGUgYnVmZmVyIGluZm9cbiAqIEBwYXJhbSBleHRlbnNpb24gLSB0aGUgZXh0ZW5zaW9uIHRvIHVzZVxuICogQHJldHVybnMgdGhlIG5ldyBpbWFnZSBuYW1lIHRoYXQgaXMgbm90IHRha2VuXG4gKi9cbmNvbnN0IGNyZWF0ZUltYWdlTmFtZSA9IChcbiAgb3V0cHV0SW1hZ2VOYW1lOiBzdHJpbmcsXG4gIHsgaGVpZ2h0LCB3aWR0aCB9OiBPdXRwdXRJbmZvLFxuICBleHRlbnNpb246IHN0cmluZyxcbikgPT4gYCR7b3V0cHV0SW1hZ2VOYW1lfS0ke3dpZHRofXgke2hlaWdodH0uJHtleHRlbnNpb259YFxuXG4vKipcbiAqIENyZWF0ZSB0aGUgcmVzdWx0IG9iamVjdCBmb3IgdGhlIGltYWdlIHJlc2l6ZSBvcGVyYXRpb24gYmFzZWQgb24gdGhlXG4gKiBwcm92aWRlZCBwYXJhbWV0ZXJzLiBJZiB0aGUgbmFtZSBpcyBub3QgcHJvdmlkZWQsIGFuIGVtcHR5IHJlc3VsdCBvYmplY3RcbiAqIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gZmlsZW5hbWUgLSB0aGUgZmlsZW5hbWUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gd2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgaW1hZ2VcbiAqIEBwYXJhbSBmaWxlc2l6ZSAtIHRoZSBmaWxlc2l6ZSBvZiB0aGUgaW1hZ2VcbiAqIEBwYXJhbSBtaW1lVHlwZSAtIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gc2l6ZXNUb1NhdmUgLSB0aGUgc2l6ZXMgdG8gc2F2ZVxuICogQHJldHVybnMgdGhlIHJlc3VsdCBvYmplY3RcbiAqL1xuY29uc3QgY3JlYXRlUmVzdWx0ID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIGZpbGVuYW1lOiBGaWxlU2l6ZVsnZmlsZW5hbWUnXSA9IG51bGwsXG4gIHdpZHRoOiBGaWxlU2l6ZVsnd2lkdGgnXSA9IG51bGwsXG4gIGhlaWdodDogRmlsZVNpemVbJ2hlaWdodCddID0gbnVsbCxcbiAgZmlsZXNpemU6IEZpbGVTaXplWydmaWxlc2l6ZSddID0gbnVsbCxcbiAgbWltZVR5cGU6IEZpbGVTaXplWydtaW1lVHlwZSddID0gbnVsbCxcbiAgc2l6ZXNUb1NhdmU6IEZpbGVUb1NhdmVbXSA9IFtdLFxuKTogSW1hZ2VTaXplc1Jlc3VsdCA9PiAoe1xuICBzaXplRGF0YToge1xuICAgIFtuYW1lXToge1xuICAgICAgZmlsZW5hbWUsXG4gICAgICBmaWxlc2l6ZSxcbiAgICAgIGhlaWdodCxcbiAgICAgIG1pbWVUeXBlLFxuICAgICAgd2lkdGgsXG4gICAgfSxcbiAgfSxcbiAgc2l6ZXNUb1NhdmUsXG59KVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBpbWFnZSBuZWVkcyB0byBiZSByZXNpemVkIGFjY29yZGluZyB0byB0aGUgcmVxdWVzdGVkIGRpbWVuc2lvbnNcbiAqIGFuZCB0aGUgb3JpZ2luYWwgaW1hZ2Ugc2l6ZS4gSWYgdGhlIHJlc2l6ZSBvcHRpb25zIHdpdGhvdXRFbmxhcmdlbWVudCBvciB3aXRob3V0UmVkdWN0aW9uIGFyZSBwcm92aWRlZCxcbiAqIHRoZSBpbWFnZSB3aWxsIGJlIHJlc2l6ZWQgcmVnYXJkbGVzcyBvZiB0aGUgcmVxdWVzdGVkIGRpbWVuc2lvbnMsIGdpdmVuIHRoYXQgdGhlXG4gKiB3aWR0aCBvciBoZWlnaHQgdG8gYmUgcmVzaXplZCBpcyBwcm92aWRlZC5cbiAqXG4gKiBAcGFyYW0gcmVzaXplQ29uZmlnIC0gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3RlZCBkaW1lbnNpb25zIGFuZCByZXNpemUgb3B0aW9uc1xuICogQHBhcmFtIG9yaWdpbmFsIC0gdGhlIG9yaWdpbmFsIGltYWdlIHNpemVcbiAqIEByZXR1cm5zIHRydWUgaWYgcmVzaXppbmcgaXMgbm90IG5lZWRlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmNvbnN0IHByZXZlbnRSZXNpemUgPSAoXG4gIHsgaGVpZ2h0OiBkZXNpcmVkSGVpZ2h0LCB3aWR0aDogZGVzaXJlZFdpZHRoLCB3aXRob3V0RW5sYXJnZW1lbnQsIHdpdGhvdXRSZWR1Y3Rpb24gfTogSW1hZ2VTaXplLFxuICBvcmlnaW5hbDogUHJvYmVkSW1hZ2VTaXplLFxuKTogYm9vbGVhbiA9PiB7XG4gIC8vIGRlZmF1bHQgaXMgdG8gYWxsb3cgcmVkdWN0aW9uXG4gIGlmICh3aXRob3V0UmVkdWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2UgLy8gbmVlZHMgcmVzaXplXG4gIH1cblxuICAvLyBkZWZhdWx0IGlzIHRvIHByZXZlbnQgZW5sYXJnZW1lbnRcbiAgaWYgKHdpdGhvdXRFbmxhcmdlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlIC8vIG5lZWRzIHJlc2l6ZVxuICB9XG5cbiAgY29uc3QgaXNXaWR0aE9ySGVpZ2h0Tm90RGVmaW5lZCA9ICFkZXNpcmVkSGVpZ2h0IHx8ICFkZXNpcmVkV2lkdGhcbiAgaWYgKGlzV2lkdGhPckhlaWdodE5vdERlZmluZWQpIHtcbiAgICAvLyBJZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBub3QgZGVmaW5lZCwgaXQgbWVhbnMgdGhlcmUgaXMgYSBmb3JtYXQgY29udmVyc2lvblxuICAgIC8vIGFuZCB0aGUgaW1hZ2UgbmVlZHMgdG8gYmUgXCJyZXNpemVkXCIgKHRyYW5zZm9ybWVkKS5cbiAgICByZXR1cm4gZmFsc2UgLy8gbmVlZHMgcmVzaXplXG4gIH1cblxuICBjb25zdCBoYXNJbnN1ZmZpY2llbnRXaWR0aCA9IGRlc2lyZWRXaWR0aCA+IG9yaWdpbmFsLndpZHRoXG4gIGNvbnN0IGhhc0luc3VmZmljaWVudEhlaWdodCA9IGRlc2lyZWRIZWlnaHQgPiBvcmlnaW5hbC5oZWlnaHRcbiAgaWYgKGhhc0luc3VmZmljaWVudFdpZHRoICYmIGhhc0luc3VmZmljaWVudEhlaWdodCkge1xuICAgIC8vIGRvZXNuJ3QgbmVlZCByZXNpemUgLSBwcmV2ZW50IGVubGFyZ2VtZW50LiBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiBib3RoIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGluc3VmZmljaWVudC5cbiAgICAvLyBpZiBvbmx5IG9uZSBkaW1lbnNpb24gaXMgaW5zdWZmaWNpZW50IGFuZCB0aGUgb3RoZXIgaXMgc3VmZmljaWVudCwgcmVzaXppbmcgbmVlZHMgdG8gaGFwcGVuLCBhcyB0aGUgaW1hZ2VcbiAgICAvLyBzaG91bGQgYmUgcmVzaXplZCB0byB0aGUgc3VmZmljaWVudCBkaW1lbnNpb24uXG4gICAgcmV0dXJuIHRydWUgLy8gZG8gbm90IGNyZWF0ZSBhIG5ldyBzaXplXG4gIH1cblxuICByZXR1cm4gZmFsc2UgLy8gbmVlZHMgcmVzaXplXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGltYWdlIHNob3VsZCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gc2hhcnAgd2l0aG91dCBwYXlsb2FkIGFkanVzdGluZyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSByZXNpemVDb25maWcgLSBvYmplY3QgY29udGFpbmluZyB0aGUgcmVxdWVzdGVkIGRpbWVuc2lvbnMgYW5kIHJlc2l6ZSBvcHRpb25zXG4gKiBAcGFyYW0gb3JpZ2luYWwgLSB0aGUgb3JpZ2luYWwgaW1hZ2Ugc2l6ZVxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgaW1hZ2Ugc2hvdWxkIHBhc3NlZCBkaXJlY3RseSB0byBzaGFycFxuICovXG5jb25zdCBhcHBseVBheWxvYWRBZGp1c3RtZW50cyA9IChcbiAgeyBmaXQsIGhlaWdodCwgd2lkdGgsIHdpdGhvdXRFbmxhcmdlbWVudCwgd2l0aG91dFJlZHVjdGlvbiB9OiBJbWFnZVNpemUsXG4gIG9yaWdpbmFsOiBQcm9iZWRJbWFnZVNpemUsXG4pID0+IHtcbiAgaWYgKGZpdCA9PT0gJ2NvbnRhaW4nIHx8IGZpdCA9PT0gJ2luc2lkZScpIHJldHVybiBmYWxzZVxuICBpZiAoIWlzTnVtYmVyKGhlaWdodCkgJiYgIWlzTnVtYmVyKHdpZHRoKSkgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3QgdGFyZ2V0QXNwZWN0UmF0aW8gPSB3aWR0aCAvIGhlaWdodFxuICBjb25zdCBvcmlnaW5hbEFzcGVjdFJhdGlvID0gb3JpZ2luYWwud2lkdGggLyBvcmlnaW5hbC5oZWlnaHRcbiAgaWYgKG9yaWdpbmFsQXNwZWN0UmF0aW8gPT09IHRhcmdldEFzcGVjdFJhdGlvKSByZXR1cm4gZmFsc2VcblxuICBjb25zdCBza2lwRW5sYXJnZW1lbnQgPSB3aXRob3V0RW5sYXJnZW1lbnQgJiYgKG9yaWdpbmFsLmhlaWdodCA8IGhlaWdodCB8fCBvcmlnaW5hbC53aWR0aCA8IHdpZHRoKVxuICBjb25zdCBza2lwUmVkdWN0aW9uID0gd2l0aG91dFJlZHVjdGlvbiAmJiAob3JpZ2luYWwuaGVpZ2h0ID4gaGVpZ2h0IHx8IG9yaWdpbmFsLndpZHRoID4gd2lkdGgpXG4gIGlmIChza2lwRW5sYXJnZW1lbnQgfHwgc2tpcFJlZHVjdGlvbikgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSB0aGUgcmVzaXplIGNvbmZpZy4gSWYgdGhlIHJlc2l6ZSBjb25maWcgaGFzIHRoZSBgd2l0aG91dFJlZHVjdGlvbmBcbiAqIHByb3BlcnR5IHNldCB0byB0cnVlLCB0aGUgYGZpdGAgYW5kIGBwb3NpdGlvbmAgcHJvcGVydGllcyB3aWxsIGJlIHNldCB0byBgY29udGFpbmBcbiAqIGFuZCBgdG9wIGxlZnRgIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBAcGFyYW0gcmVzaXplQ29uZmlnIC0gdGhlIHJlc2l6ZSBjb25maWdcbiAqIEByZXR1cm5zIGEgc2FuaXRpemVkIHJlc2l6ZSBjb25maWdcbiAqL1xuY29uc3Qgc2FuaXRpemVSZXNpemVDb25maWcgPSAocmVzaXplQ29uZmlnOiBJbWFnZVNpemUpOiBJbWFnZVNpemUgPT4ge1xuICBpZiAocmVzaXplQ29uZmlnLndpdGhvdXRSZWR1Y3Rpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzaXplQ29uZmlnLFxuICAgICAgLy8gV2h5IGZpdCBgY29udGFpbmAgc2hvdWxkIGFsc28gYmUgc2V0IHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9sb3ZlbGwvc2hhcnAvaXNzdWVzLzM1OTVcbiAgICAgIGZpdDogcmVzaXplQ29uZmlnPy5maXQgfHwgJ2NvbnRhaW4nLFxuICAgICAgcG9zaXRpb246IHJlc2l6ZUNvbmZpZz8ucG9zaXRpb24gfHwgJ2xlZnQgdG9wJyxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc2l6ZUNvbmZpZ1xufVxuXG4vKipcbiAqIEZvciB0aGUgcHJvdmlkZWQgaW1hZ2Ugc2l6ZXMsIGhhbmRsZSB0aGUgcmVzaXppbmcgYW5kIHRoZSB0cmFuc2Zvcm1zXG4gKiAoZm9ybWF0LCB0cmltLCBldGMuKSBvZiBlYWNoIHJlcXVlc3RlZCBpbWFnZSBzaXplIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBvYmplY3QuXG4gKiBUaGlzIG9ubHkgaGFuZGxlcyB0aGUgaW1hZ2Ugc2l6ZXMuIFRoZSB0cmFuc2Zvcm1zIG9mIHRoZSBvcmlnaW5hbCBpbWFnZVxuICogYXJlIGhhbmRsZWQgaW4ge0BsaW5rIC4vZ2VuZXJhdGVGaWxlRGF0YS50c30uXG4gKlxuICogVGhlIGltYWdlIHdpbGwgYmUgcmVzaXplZCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkXG4gKiByZXNpemUgY29uZmlnLiBJZiBubyBpbWFnZSBzaXplcyBhcmUgcmVxdWVzdGVkLCB0aGUgcmVzb2x2ZWQgZGF0YSB3aWxsIGJlIGVtcHR5LlxuICogRm9yIGV2ZXJ5IGltYWdlIHRoYXQgZG9zIG5vdCBuZWVkIHRvIGJlIHJlc2l6ZWQsIGFuIHJlc3VsdCBvYmplY3Qgd2l0aCBgbnVsbGBcbiAqIHBhcmFtZXRlcnMgd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gcmVzaXplQ29uZmlnIC0gdGhlIHJlc2l6ZSBjb25maWdcbiAqIEByZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIHJlc2l6ZSBvcGVyYXRpb24ocylcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcmVzaXplQW5kVHJhbnNmb3JtSW1hZ2VTaXplcyh7XG4gIGNvbmZpZyxcbiAgZGltZW5zaW9ucyxcbiAgZmlsZSxcbiAgbWltZVR5cGUsXG4gIHJlcSxcbiAgc2F2ZWRGaWxlbmFtZSxcbiAgc3RhdGljUGF0aCxcbn06IFJlc2l6ZUFyZ3MpOiBQcm9taXNlPEltYWdlU2l6ZXNSZXN1bHQ+IHtcbiAgY29uc3QgeyBpbWFnZVNpemVzIH0gPSBjb25maWcudXBsb2FkXG4gIC8vIE5vdGluZyB0byByZXNpemUgaGVyZSBzbyByZXR1cm4gYXMgZWFybHkgYXMgcG9zc2libGVcbiAgaWYgKCFpbWFnZVNpemVzKSByZXR1cm4geyBzaXplRGF0YToge30sIHNpemVzVG9TYXZlOiBbXSB9XG5cbiAgY29uc3Qgc2hhcnBCYXNlID0gc2hhcnAoZmlsZS50ZW1wRmlsZVBhdGggfHwgZmlsZS5kYXRhKS5yb3RhdGUoKSAvLyBwYXNzIHJvdGF0ZSgpIHRvIGF1dG8tcm90YXRlIGJhc2VkIG9uIEVYSUYgZGF0YS4gaHR0cHM6Ly9naXRodWIuY29tL3BheWxvYWRjbXMvcGF5bG9hZC9wdWxsLzMwODFcblxuICBjb25zdCByZXN1bHRzOiBJbWFnZVNpemVzUmVzdWx0W10gPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBpbWFnZVNpemVzLm1hcChhc3luYyAoaW1hZ2VSZXNpemVDb25maWcpOiBQcm9taXNlPEltYWdlU2l6ZXNSZXN1bHQ+ID0+IHtcbiAgICAgIGltYWdlUmVzaXplQ29uZmlnID0gc2FuaXRpemVSZXNpemVDb25maWcoaW1hZ2VSZXNpemVDb25maWcpXG5cbiAgICAgIC8vIFRoaXMgY2hlY2tzIGlmIGEgcmVzaXplIHNob3VsZCBoYXBwZW4uIElmIG5vdCwgdGhlIHJlc2l6ZWQgaW1hZ2Ugd2lsbCBiZVxuICAgICAgLy8gc2tpcHBlZCBDT01QTEVURUxZIGFuZCB0aHVzIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgaW1hZ2VzLlxuICAgICAgLy8gQWxsIGZ1cnRoZXIgZm9ybWF0L3RyaW0gb3B0aW9ucyB3aWxsIHRodXMgYmUgc2tpcHBlZCBhcyB3ZWxsLlxuICAgICAgaWYgKHByZXZlbnRSZXNpemUoaW1hZ2VSZXNpemVDb25maWcsIGRpbWVuc2lvbnMpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZXN1bHQoaW1hZ2VSZXNpemVDb25maWcubmFtZSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW1hZ2VUb1Jlc2l6ZSA9IHNoYXJwQmFzZS5jbG9uZSgpXG4gICAgICBsZXQgcmVzaXplZCA9IGltYWdlVG9SZXNpemVcblxuICAgICAgaWYgKFxuICAgICAgICByZXEucXVlcnk/LnVwbG9hZEVkaXRzPy5mb2NhbFBvaW50ICYmXG4gICAgICAgIGFwcGx5UGF5bG9hZEFkanVzdG1lbnRzKGltYWdlUmVzaXplQ29uZmlnLCBkaW1lbnNpb25zKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0OiByZXNpemVIZWlnaHQsIHdpZHRoOiByZXNpemVXaWR0aCB9ID0gaW1hZ2VSZXNpemVDb25maWdcbiAgICAgICAgY29uc3QgcmVzaXplQXNwZWN0UmF0aW8gPSByZXNpemVXaWR0aCAvIHJlc2l6ZUhlaWdodFxuICAgICAgICBjb25zdCBvcmlnaW5hbEFzcGVjdFJhdGlvID0gZGltZW5zaW9ucy53aWR0aCAvIGRpbWVuc2lvbnMuaGVpZ2h0XG4gICAgICAgIGNvbnN0IHByaW9yaXRpemVIZWlnaHQgPSByZXNpemVBc3BlY3RSYXRpbyA8IG9yaWdpbmFsQXNwZWN0UmF0aW9cblxuICAgICAgICAvLyBTY2FsZSB0aGUgaW1hZ2UgdXAgb3IgZG93biB0byBmaXQgdGhlIHJlc2l6ZSBkaW1lbnNpb25zXG4gICAgICAgIGNvbnN0IHNjYWxlZEltYWdlID0gaW1hZ2VUb1Jlc2l6ZS5yZXNpemUoe1xuICAgICAgICAgIGhlaWdodDogcHJpb3JpdGl6ZUhlaWdodCA/IHJlc2l6ZUhlaWdodCA6IG51bGwsXG4gICAgICAgICAgd2lkdGg6IHByaW9yaXRpemVIZWlnaHQgPyBudWxsIDogcmVzaXplV2lkdGgsXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IHsgaW5mbzogc2NhbGVkSW1hZ2VJbmZvIH0gPSBhd2FpdCBzY2FsZWRJbWFnZS50b0J1ZmZlcih7IHJlc29sdmVXaXRoT2JqZWN0OiB0cnVlIH0pXG5cbiAgICAgICAgLy8gRm9jYWwgcG9pbnQgYWRqdXN0bWVudHNcbiAgICAgICAgY29uc3QgZm9jYWxQb2ludCA9IHtcbiAgICAgICAgICB4OiBpc051bWJlcihyZXEucXVlcnkudXBsb2FkRWRpdHMuZm9jYWxQb2ludD8ueClcbiAgICAgICAgICAgID8gcmVxLnF1ZXJ5LnVwbG9hZEVkaXRzLmZvY2FsUG9pbnQueFxuICAgICAgICAgICAgOiA1MCxcbiAgICAgICAgICB5OiBpc051bWJlcihyZXEucXVlcnkudXBsb2FkRWRpdHMuZm9jYWxQb2ludD8ueSlcbiAgICAgICAgICAgID8gcmVxLnF1ZXJ5LnVwbG9hZEVkaXRzLmZvY2FsUG9pbnQueVxuICAgICAgICAgICAgOiA1MCxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNhZmVSZXNpemVXaWR0aCA9IHJlc2l6ZVdpZHRoID8/IHNjYWxlZEltYWdlSW5mby53aWR0aFxuICAgICAgICBjb25zdCBtYXhPZmZzZXRYID0gc2NhbGVkSW1hZ2VJbmZvLndpZHRoIC0gc2FmZVJlc2l6ZVdpZHRoXG4gICAgICAgIGNvbnN0IGxlZnRGb2NhbEVkZ2UgPSBNYXRoLnJvdW5kKFxuICAgICAgICAgIHNjYWxlZEltYWdlSW5mby53aWR0aCAqIChmb2NhbFBvaW50LnggLyAxMDApIC0gc2FmZVJlc2l6ZVdpZHRoIC8gMixcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBzYWZlT2Zmc2V0WCA9IE1hdGgubWluKE1hdGgubWF4KDAsIGxlZnRGb2NhbEVkZ2UpLCBtYXhPZmZzZXRYKVxuXG4gICAgICAgIGNvbnN0IHNhZmVSZXNpemVIZWlnaHQgPSByZXNpemVIZWlnaHQgPz8gc2NhbGVkSW1hZ2VJbmZvLmhlaWdodFxuICAgICAgICBjb25zdCBtYXhPZmZzZXRZID0gc2NhbGVkSW1hZ2VJbmZvLmhlaWdodCAtIHNhZmVSZXNpemVIZWlnaHRcbiAgICAgICAgY29uc3QgdG9wRm9jYWxFZGdlID0gTWF0aC5yb3VuZChcbiAgICAgICAgICBzY2FsZWRJbWFnZUluZm8uaGVpZ2h0ICogKGZvY2FsUG9pbnQueSAvIDEwMCkgLSBzYWZlUmVzaXplSGVpZ2h0IC8gMixcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBzYWZlT2Zmc2V0WSA9IE1hdGgubWluKE1hdGgubWF4KDAsIHRvcEZvY2FsRWRnZSksIG1heE9mZnNldFkpXG5cbiAgICAgICAgLy8gZXh0cmFjdCB0aGUgZm9jYWwgYXJlYSBmcm9tIHRoZSBzY2FsZWQgaW1hZ2VcbiAgICAgICAgcmVzaXplZCA9IHNjYWxlZEltYWdlLmV4dHJhY3Qoe1xuICAgICAgICAgIGhlaWdodDogc2FmZVJlc2l6ZUhlaWdodCxcbiAgICAgICAgICBsZWZ0OiBzYWZlT2Zmc2V0WCxcbiAgICAgICAgICB0b3A6IHNhZmVPZmZzZXRZLFxuICAgICAgICAgIHdpZHRoOiBzYWZlUmVzaXplV2lkdGgsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNpemVkID0gaW1hZ2VUb1Jlc2l6ZS5yZXNpemUoaW1hZ2VSZXNpemVDb25maWcpXG4gICAgICB9XG5cbiAgICAgIGlmIChpbWFnZVJlc2l6ZUNvbmZpZy5mb3JtYXRPcHRpb25zKSB7XG4gICAgICAgIHJlc2l6ZWQgPSByZXNpemVkLnRvRm9ybWF0KFxuICAgICAgICAgIGltYWdlUmVzaXplQ29uZmlnLmZvcm1hdE9wdGlvbnMuZm9ybWF0LFxuICAgICAgICAgIGltYWdlUmVzaXplQ29uZmlnLmZvcm1hdE9wdGlvbnMub3B0aW9ucyxcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoaW1hZ2VSZXNpemVDb25maWcudHJpbU9wdGlvbnMpIHtcbiAgICAgICAgcmVzaXplZCA9IHJlc2l6ZWQudHJpbShpbWFnZVJlc2l6ZUNvbmZpZy50cmltT3B0aW9ucylcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBkYXRhOiBidWZmZXJEYXRhLCBpbmZvOiBidWZmZXJJbmZvIH0gPSBhd2FpdCByZXNpemVkLnRvQnVmZmVyKHtcbiAgICAgICAgcmVzb2x2ZVdpdGhPYmplY3Q6IHRydWUsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBzYW5pdGl6ZWRJbWFnZSA9IGdldFNhbml0aXplZEltYWdlRGF0YShzYXZlZEZpbGVuYW1lKVxuXG4gICAgICBpZiAocmVxLnBheWxvYWRVcGxvYWRTaXplcykge1xuICAgICAgICByZXEucGF5bG9hZFVwbG9hZFNpemVzW2ltYWdlUmVzaXplQ29uZmlnLm5hbWVdID0gYnVmZmVyRGF0YVxuICAgICAgfVxuXG4gICAgICBjb25zdCBtaW1lSW5mbyA9IGF3YWl0IGZyb21CdWZmZXIoYnVmZmVyRGF0YSlcblxuICAgICAgY29uc3QgaW1hZ2VOYW1lV2l0aERpbWVuc2lvbnMgPSBjcmVhdGVJbWFnZU5hbWUoXG4gICAgICAgIHNhbml0aXplZEltYWdlLm5hbWUsXG4gICAgICAgIGJ1ZmZlckluZm8sXG4gICAgICAgIG1pbWVJbmZvPy5leHQgfHwgc2FuaXRpemVkSW1hZ2UuZXh0LFxuICAgICAgKVxuXG4gICAgICBjb25zdCBpbWFnZVBhdGggPSBgJHtzdGF0aWNQYXRofS8ke2ltYWdlTmFtZVdpdGhEaW1lbnNpb25zfWBcblxuICAgICAgaWYgKGF3YWl0IGZpbGVFeGlzdHMoaW1hZ2VQYXRoKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZzLnVubGlua1N5bmMoaW1hZ2VQYXRoKVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvLyBJZ25vcmUgdW5saW5rIGVycm9yc1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgaGVpZ2h0LCBzaXplLCB3aWR0aCB9ID0gYnVmZmVySW5mb1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlc3VsdChcbiAgICAgICAgaW1hZ2VSZXNpemVDb25maWcubmFtZSxcbiAgICAgICAgaW1hZ2VOYW1lV2l0aERpbWVuc2lvbnMsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHNpemUsXG4gICAgICAgIG1pbWVJbmZvPy5taW1lIHx8IG1pbWVUeXBlLFxuICAgICAgICBbeyBidWZmZXI6IGJ1ZmZlckRhdGEsIHBhdGg6IGltYWdlUGF0aCB9XSxcbiAgICAgIClcbiAgICB9KSxcbiAgKVxuXG4gIHJldHVybiByZXN1bHRzLnJlZHVjZShcbiAgICAoYWNjLCByZXN1bHQpID0+IHtcbiAgICAgIE9iamVjdC5hc3NpZ24oYWNjLnNpemVEYXRhLCByZXN1bHQuc2l6ZURhdGEpXG4gICAgICBhY2Muc2l6ZXNUb1NhdmUucHVzaCguLi5yZXN1bHQuc2l6ZXNUb1NhdmUpXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSxcbiAgICB7IHNpemVEYXRhOiB7fSwgc2l6ZXNUb1NhdmU6IFtdIH0sXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJyZXNpemVBbmRUcmFuc2Zvcm1JbWFnZVNpemVzIiwiZ2V0U2FuaXRpemVkSW1hZ2VEYXRhIiwic291cmNlSW1hZ2UiLCJleHRlbnNpb24iLCJzcGxpdCIsInBvcCIsIm5hbWUiLCJzYW5pdGl6ZSIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwiZXh0IiwiY3JlYXRlSW1hZ2VOYW1lIiwib3V0cHV0SW1hZ2VOYW1lIiwiaGVpZ2h0Iiwid2lkdGgiLCJjcmVhdGVSZXN1bHQiLCJmaWxlbmFtZSIsImZpbGVzaXplIiwibWltZVR5cGUiLCJzaXplc1RvU2F2ZSIsInNpemVEYXRhIiwicHJldmVudFJlc2l6ZSIsImRlc2lyZWRIZWlnaHQiLCJkZXNpcmVkV2lkdGgiLCJ3aXRob3V0RW5sYXJnZW1lbnQiLCJ3aXRob3V0UmVkdWN0aW9uIiwib3JpZ2luYWwiLCJ1bmRlZmluZWQiLCJpc1dpZHRoT3JIZWlnaHROb3REZWZpbmVkIiwiaGFzSW5zdWZmaWNpZW50V2lkdGgiLCJoYXNJbnN1ZmZpY2llbnRIZWlnaHQiLCJhcHBseVBheWxvYWRBZGp1c3RtZW50cyIsImZpdCIsImlzTnVtYmVyIiwidGFyZ2V0QXNwZWN0UmF0aW8iLCJvcmlnaW5hbEFzcGVjdFJhdGlvIiwic2tpcEVubGFyZ2VtZW50Iiwic2tpcFJlZHVjdGlvbiIsInNhbml0aXplUmVzaXplQ29uZmlnIiwicmVzaXplQ29uZmlnIiwicG9zaXRpb24iLCJjb25maWciLCJkaW1lbnNpb25zIiwiZmlsZSIsInJlcSIsInNhdmVkRmlsZW5hbWUiLCJzdGF0aWNQYXRoIiwiaW1hZ2VTaXplcyIsInVwbG9hZCIsInNoYXJwQmFzZSIsInNoYXJwIiwidGVtcEZpbGVQYXRoIiwiZGF0YSIsInJvdGF0ZSIsInJlc3VsdHMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiaW1hZ2VSZXNpemVDb25maWciLCJpbWFnZVRvUmVzaXplIiwiY2xvbmUiLCJyZXNpemVkIiwicXVlcnkiLCJ1cGxvYWRFZGl0cyIsImZvY2FsUG9pbnQiLCJyZXNpemVIZWlnaHQiLCJyZXNpemVXaWR0aCIsInJlc2l6ZUFzcGVjdFJhdGlvIiwicHJpb3JpdGl6ZUhlaWdodCIsInNjYWxlZEltYWdlIiwicmVzaXplIiwiaW5mbyIsInNjYWxlZEltYWdlSW5mbyIsInRvQnVmZmVyIiwicmVzb2x2ZVdpdGhPYmplY3QiLCJ4IiwieSIsInNhZmVSZXNpemVXaWR0aCIsIm1heE9mZnNldFgiLCJsZWZ0Rm9jYWxFZGdlIiwiTWF0aCIsInJvdW5kIiwic2FmZU9mZnNldFgiLCJtaW4iLCJtYXgiLCJzYWZlUmVzaXplSGVpZ2h0IiwibWF4T2Zmc2V0WSIsInRvcEZvY2FsRWRnZSIsInNhZmVPZmZzZXRZIiwiZXh0cmFjdCIsImxlZnQiLCJ0b3AiLCJmb3JtYXRPcHRpb25zIiwidG9Gb3JtYXQiLCJmb3JtYXQiLCJvcHRpb25zIiwidHJpbU9wdGlvbnMiLCJ0cmltIiwiYnVmZmVyRGF0YSIsImJ1ZmZlckluZm8iLCJzYW5pdGl6ZWRJbWFnZSIsInBheWxvYWRVcGxvYWRTaXplcyIsIm1pbWVJbmZvIiwiZnJvbUJ1ZmZlciIsImltYWdlTmFtZVdpdGhEaW1lbnNpb25zIiwiaW1hZ2VQYXRoIiwiZmlsZUV4aXN0cyIsImZzIiwidW5saW5rU3luYyIsInNpemUiLCJtaW1lIiwiYnVmZmVyIiwicGF0aCIsInJlZHVjZSIsImFjYyIsInJlc3VsdCIsIk9iamVjdCIsImFzc2lnbiIsInB1c2giXSwibWFwcGluZ3MiOiI7Ozs7K0JBbU1BOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDRDs7O2VBQThCQTs7OzBCQTlNSDsyREFDWjt5RUFDTTs4REFDSDswQkFPTzttRUFDRjs7Ozs7O0FBMkJ2Qjs7Ozs7Q0FLQyxHQUNELE1BQU1DLHdCQUF3QixDQUFDQztJQUM3QixNQUFNQyxZQUFZRCxZQUFZRSxLQUFLLENBQUMsS0FBS0MsR0FBRztJQUM1QyxNQUFNQyxPQUFPQyxJQUFBQSx5QkFBUSxFQUFDTCxZQUFZTSxTQUFTLENBQUMsR0FBR04sWUFBWU8sV0FBVyxDQUFDLFNBQVNQO0lBQ2hGLE9BQU87UUFBRUk7UUFBTUksS0FBS1A7SUFBVTtBQUNoQztBQUVBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNELE1BQU1RLGtCQUFrQixDQUN0QkMsaUJBQ0EsRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQWMsRUFDN0JYLFlBQ0csQ0FBQyxFQUFFUyxnQkFBZ0IsQ0FBQyxFQUFFRSxNQUFNLENBQUMsRUFBRUQsT0FBTyxDQUFDLEVB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