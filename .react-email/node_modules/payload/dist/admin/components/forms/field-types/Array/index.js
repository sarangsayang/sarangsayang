"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _validations = require("../../../../../fields/validations");
const _getTranslation = require("../../../../../utilities/getTranslation");
const _scrollToID = require("../../../../utilities/scrollToID");
const _Banner = /*#__PURE__*/ _interop_require_default(require("../../../elements/Banner"));
const _Button = /*#__PURE__*/ _interop_require_default(require("../../../elements/Button"));
const _DraggableSortable = /*#__PURE__*/ _interop_require_default(require("../../../elements/DraggableSortable"));
const _DraggableSortableItem = /*#__PURE__*/ _interop_require_default(require("../../../elements/DraggableSortable/DraggableSortableItem"));
const _ErrorPill = require("../../../elements/ErrorPill");
const _Config = require("../../../utilities/Config");
const _DocumentInfo = require("../../../utilities/DocumentInfo");
const _Locale = require("../../../utilities/Locale");
const _Error = /*#__PURE__*/ _interop_require_default(require("../../Error"));
const _FieldDescription = /*#__PURE__*/ _interop_require_default(require("../../FieldDescription"));
const _context = require("../../Form/context");
const _NullifyField = require("../../NullifyField");
const _useField = /*#__PURE__*/ _interop_require_default(require("../../useField"));
const _withCondition = /*#__PURE__*/ _interop_require_default(require("../../withCondition"));
const _shared = require("../shared");
const _ArrayRow = require("./ArrayRow");
require("./index.scss");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const baseClass = 'array-field';
const ArrayFieldType = (props)=>{
    const { name, admin: { className, components, condition, description, readOnly }, fieldTypes, fields, forceRender = false, indexPath, localized, maxRows, minRows, path: pathFromProps, permissions, required, validate = _validations.array } = props;
    const path = pathFromProps || name;
    // eslint-disable-next-line react/destructuring-assignment
    const label = props?.label ?? props?.labels?.singular;
    const CustomRowLabel = components?.RowLabel || undefined;
    const { setDocFieldPreferences } = (0, _DocumentInfo.useDocumentInfo)();
    const { addFieldRow, dispatchFields, removeFieldRow, setModified } = (0, _context.useForm)();
    const submitted = (0, _context.useFormSubmitted)();
    const { code: locale } = (0, _Locale.useLocale)();
    const { i18n, t } = (0, _reacti18next.useTranslation)('fields');
    const { localization } = (0, _Config.useConfig)();
    const editingDefaultLocale = (()=>{
        if (localization && localization.fallback) {
            const defaultLocale = localization.defaultLocale || 'en';
            return locale === defaultLocale;
        }
        return true;
    })();
    // Handle labeling for Arrays, Global Arrays, and Blocks
    const getLabels = (p)=>{
        if (p?.labels) return p.labels;
        if (p?.label) return {
            plural: undefined,
            singular: p.label
        };
        return {
            plural: t('rows'),
            singular: t('row')
        };
    };
    const labels = getLabels(props);
    const memoizedValidate = (0, _react.useCallback)((value, options)=>{
        // alternative locales can be null
        if (!editingDefaultLocale && value === null) {
            return true;
        }
        return validate(value, {
            ...options,
            maxRows,
            minRows,
            required
        });
    }, [
        maxRows,
        minRows,
        required,
        validate,
        editingDefaultLocale
    ]);
    const { errorMessage, rows = [], showError, valid, value } = (0, _useField.default)({
        condition,
        hasRows: true,
        path,
        validate: memoizedValidate
    });
    const addRow = (0, _react.useCallback)(async (rowIndex)=>{
        await addFieldRow({
            path,
            rowIndex
        });
        setModified(true);
        setTimeout(()=>{
            (0, _scrollToID.scrollToID)(`${path}-row-${rowIndex + 1}`);
        }, 0);
    }, [
        addFieldRow,
        path,
        setModified
    ]);
    const duplicateRow = (0, _react.useCallback)((rowIndex)=>{
        dispatchFields({
            path,
            rowIndex,
            type: 'DUPLICATE_ROW'
        });
        setModified(true);
        setTimeout(()=>{
            (0, _scrollToID.scrollToID)(`${path}-row-${rowIndex}`);
        }, 0);
    }, [
        dispatchFields,
        path,
        setModified
    ]);
    const removeRow = (0, _react.useCallback)((rowIndex)=>{
        removeFieldRow({
            path,
            rowIndex
        });
        setModified(true);
    }, [
        removeFieldRow,
        path,
        setModified
    ]);
    const moveRow = (0, _react.useCallback)((moveFromIndex, moveToIndex)=>{
        dispatchFields({
            moveFromIndex,
            moveToIndex,
            path,
            type: 'MOVE_ROW'
        });
        setModified(true);
    }, [
        dispatchFields,
        path,
        setModified
    ]);
    const toggleCollapseAll = (0, _react.useCallback)((collapsed)=>{
        dispatchFields({
            collapsed,
            path,
            setDocFieldPreferences,
            type: 'SET_ALL_ROWS_COLLAPSED'
        });
    }, [
        dispatchFields,
        path,
        setDocFieldPreferences
    ]);
    const setCollapse = (0, _react.useCallback)((rowID, collapsed)=>{
        dispatchFields({
            collapsed,
            path,
            rowID,
            setDocFieldPreferences,
            type: 'SET_ROW_COLLAPSED'
        });
    }, [
        dispatchFields,
        path,
        setDocFieldPreferences
    ]);
    const hasMaxRows = maxRows && rows.length >= maxRows;
    const fieldErrorCount = rows.reduce((total, row)=>total + (row?.childErrorPaths?.size || 0), 0) + (valid ? 0 : 1);
    const fieldHasErrors = submitted && fieldErrorCount > 0;
    const showRequired = readOnly && rows.length === 0;
    const showMinRows = rows.length < minRows || required && rows.length === 0;
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: [
            _shared.fieldBaseClass,
            baseClass,
            className,
            fieldHasErrors ? `${baseClass}--has-error` : `${baseClass}--has-no-error`
        ].filter(Boolean).join(' '),
        id: `field-${path.replace(/\./g, '__')}`
    }, showError && /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__error-wrap`
    }, /*#__PURE__*/ _react.default.createElement(_Error.default, {
        message: errorMessage,
        showError: showError
    })), /*#__PURE__*/ _react.default.createElement("header", {
        className: `${baseClass}__header`
    }, /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__header-wrap`
    }, /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__header-content`
    }, /*#__PURE__*/ _react.default.createElement("h3", {
        className: `${baseClass}__title`
    }, (0, _getTranslation.getTranslation)(label || name, i18n)), fieldHasErrors && fieldErrorCount > 0 && /*#__PURE__*/ _react.default.createElement(_ErrorPill.ErrorPill, {
        count: fieldErrorCount,
        withMessage: true
    })), rows.length > 0 && /*#__PURE__*/ _react.default.createElement("ul", {
        className: `${baseClass}__header-actions`
    }, /*#__PURE__*/ _react.default.createElement("li", null, /*#__PURE__*/ _react.default.createElement("button", {
        className: `${baseClass}__header-action`,
        onClick: ()=>toggleCollapseAll(true),
        type: "button"
    }, t('collapseAll'))), /*#__PURE__*/ _react.default.createElement("li", null, /*#__PURE__*/ _react.default.createElement("button", {
        className: `${baseClass}__header-action`,
        onClick: ()=>toggleCollapseAll(false),
        type: "button"
    }, t('showAll'))))), /*#__PURE__*/ _react.default.createElement(_FieldDescription.default, {
        className: `field-description-${path.replace(/\./g, '__')}`,
        description: description,
        path: path,
        value: value
    })), /*#__PURE__*/ _react.default.createElement(_NullifyField.NullifyLocaleField, {
        fieldValue: value,
        localized: localized,
        path: path
    }), (rows.length > 0 || !valid && (showRequired || showMinRows)) && /*#__PURE__*/ _react.default.createElement(_DraggableSortable.default, {
        className: `${baseClass}__draggable-rows`,
        ids: rows.map((row)=>row.id),
        onDragEnd: ({ moveFromIndex, moveToIndex })=>moveRow(moveFromIndex, moveToIndex)
    }, rows.map((row, i)=>/*#__PURE__*/ _react.default.createElement(_DraggableSortableItem.default, {
            disabled: readOnly,
            id: row.id,
            key: row.id
        }, (draggableSortableItemProps)=>/*#__PURE__*/ _react.default.createElement(_ArrayRow.ArrayRow, {
                ...draggableSortableItemProps,
                CustomRowLabel: CustomRowLabel,
                addRow: addRow,
                duplicateRow: duplicateRow,
                fieldTypes: fieldTypes,
                fields: fields,
                forceRender: forceRender,
                hasMaxRows: hasMaxRows,
                indexPath: indexPath,
                labels: labels,
                moveRow: moveRow,
                path: path,
                permissions: permissions,
                readOnly: readOnly,
                removeRow: removeRow,
                row: row,
                rowCount: rows.length,
                rowIndex: i,
                setCollapse: setCollapse
            }))), !valid && /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, showRequired && /*#__PURE__*/ _react.default.createElement(_Banner.default, null, t('validation:fieldHasNo', {
        label: (0, _getTranslation.getTranslation)(labels.plural, i18n)
    })), showMinRows && /*#__PURE__*/ _react.default.createElement(_Banner.default, {
        type: "error"
    }, t('validation:requiresAtLeast', {
        count: minRows,
        label: (0, _getTranslation.getTranslation)(minRows ? labels.plural : labels.singular, i18n) || t(minRows > 1 ? 'general:row' : 'general:rows')
    })))), !readOnly && !hasMaxRows && /*#__PURE__*/ _react.default.createElement(_Button.default, {
        buttonStyle: "icon-label",
        className: `${baseClass}__add-row`,
        icon: "plus",
        iconPosition: "left",
        iconStyle: "with-border",
        onClick: ()=>addRow(value || 0)
    }, t('addLabel', {
        label: (0, _getTranslation.getTranslation)(labels.singular, i18n)
    })));
};
const _default = (0, _withCondition.default)(ArrayFieldType);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2Zvcm1zL2ZpZWxkLXR5cGVzL0FycmF5L2luZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZVRyYW5zbGF0aW9uIH0gZnJvbSAncmVhY3QtaTE4bmV4dCdcblxuaW1wb3J0IHR5cGUgeyBQcm9wcyB9IGZyb20gJy4vdHlwZXMnXG5cbmltcG9ydCB7IGFycmF5IH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vZmllbGRzL3ZhbGlkYXRpb25zJ1xuaW1wb3J0IHsgZ2V0VHJhbnNsYXRpb24gfSBmcm9tICcuLi8uLi8uLi8uLi8uLi91dGlsaXRpZXMvZ2V0VHJhbnNsYXRpb24nXG5pbXBvcnQgeyBzY3JvbGxUb0lEIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbGl0aWVzL3Njcm9sbFRvSUQnXG5pbXBvcnQgQmFubmVyIGZyb20gJy4uLy4uLy4uL2VsZW1lbnRzL0Jhbm5lcidcbmltcG9ydCBCdXR0b24gZnJvbSAnLi4vLi4vLi4vZWxlbWVudHMvQnV0dG9uJ1xuaW1wb3J0IERyYWdnYWJsZVNvcnRhYmxlIGZyb20gJy4uLy4uLy4uL2VsZW1lbnRzL0RyYWdnYWJsZVNvcnRhYmxlJ1xuaW1wb3J0IERyYWdnYWJsZVNvcnRhYmxlSXRlbSBmcm9tICcuLi8uLi8uLi9lbGVtZW50cy9EcmFnZ2FibGVTb3J0YWJsZS9EcmFnZ2FibGVTb3J0YWJsZUl0ZW0nXG5pbXBvcnQgeyBFcnJvclBpbGwgfSBmcm9tICcuLi8uLi8uLi9lbGVtZW50cy9FcnJvclBpbGwnXG5pbXBvcnQgeyB1c2VDb25maWcgfSBmcm9tICcuLi8uLi8uLi91dGlsaXRpZXMvQ29uZmlnJ1xuaW1wb3J0IHsgdXNlRG9jdW1lbnRJbmZvIH0gZnJvbSAnLi4vLi4vLi4vdXRpbGl0aWVzL0RvY3VtZW50SW5mbydcbmltcG9ydCB7IHVzZUxvY2FsZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxpdGllcy9Mb2NhbGUnXG5pbXBvcnQgRXJyb3IgZnJvbSAnLi4vLi4vRXJyb3InXG5pbXBvcnQgRmllbGREZXNjcmlwdGlvbiBmcm9tICcuLi8uLi9GaWVsZERlc2NyaXB0aW9uJ1xuaW1wb3J0IHsgdXNlRm9ybSwgdXNlRm9ybVN1Ym1pdHRlZCB9IGZyb20gJy4uLy4uL0Zvcm0vY29udGV4dCdcbmltcG9ydCB7IE51bGxpZnlMb2NhbGVGaWVsZCB9IGZyb20gJy4uLy4uL051bGxpZnlGaWVsZCdcbmltcG9ydCB1c2VGaWVsZCBmcm9tICcuLi8uLi91c2VGaWVsZCdcbmltcG9ydCB3aXRoQ29uZGl0aW9uIGZyb20gJy4uLy4uL3dpdGhDb25kaXRpb24nXG5pbXBvcnQgeyBmaWVsZEJhc2VDbGFzcyB9IGZyb20gJy4uL3NoYXJlZCdcbmltcG9ydCB7IEFycmF5Um93IH0gZnJvbSAnLi9BcnJheVJvdydcbmltcG9ydCAnLi9pbmRleC5zY3NzJ1xuXG5jb25zdCBiYXNlQ2xhc3MgPSAnYXJyYXktZmllbGQnXG5cbmNvbnN0IEFycmF5RmllbGRUeXBlOiBSZWFjdC5GQzxQcm9wcz4gPSAocHJvcHMpID0+IHtcbiAgY29uc3Qge1xuICAgIG5hbWUsXG4gICAgYWRtaW46IHsgY2xhc3NOYW1lLCBjb21wb25lbnRzLCBjb25kaXRpb24sIGRlc2NyaXB0aW9uLCByZWFkT25seSB9LFxuICAgIGZpZWxkVHlwZXMsXG4gICAgZmllbGRzLFxuICAgIGZvcmNlUmVuZGVyID0gZmFsc2UsXG4gICAgaW5kZXhQYXRoLFxuICAgIGxvY2FsaXplZCxcbiAgICBtYXhSb3dzLFxuICAgIG1pblJvd3MsXG4gICAgcGF0aDogcGF0aEZyb21Qcm9wcyxcbiAgICBwZXJtaXNzaW9ucyxcbiAgICByZXF1aXJlZCxcbiAgICB2YWxpZGF0ZSA9IGFycmF5LFxuICB9ID0gcHJvcHNcblxuICBjb25zdCBwYXRoID0gcGF0aEZyb21Qcm9wcyB8fCBuYW1lXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rlc3RydWN0dXJpbmctYXNzaWdubWVudFxuICBjb25zdCBsYWJlbCA9IHByb3BzPy5sYWJlbCA/PyBwcm9wcz8ubGFiZWxzPy5zaW5ndWxhclxuXG4gIGNvbnN0IEN1c3RvbVJvd0xhYmVsID0gY29tcG9uZW50cz8uUm93TGFiZWwgfHwgdW5kZWZpbmVkXG5cbiAgY29uc3QgeyBzZXREb2NGaWVsZFByZWZlcmVuY2VzIH0gPSB1c2VEb2N1bWVudEluZm8oKVxuICBjb25zdCB7IGFkZEZpZWxkUm93LCBkaXNwYXRjaEZpZWxkcywgcmVtb3ZlRmllbGRSb3csIHNldE1vZGlmaWVkIH0gPSB1c2VGb3JtKClcbiAgY29uc3Qgc3VibWl0dGVkID0gdXNlRm9ybVN1Ym1pdHRlZCgpXG4gIGNvbnN0IHsgY29kZTogbG9jYWxlIH0gPSB1c2VMb2NhbGUoKVxuICBjb25zdCB7IGkxOG4sIHQgfSA9IHVzZVRyYW5zbGF0aW9uKCdmaWVsZHMnKVxuICBjb25zdCB7IGxvY2FsaXphdGlvbiB9ID0gdXNlQ29uZmlnKClcblxuICBjb25zdCBlZGl0aW5nRGVmYXVsdExvY2FsZSA9ICgoKSA9PiB7XG4gICAgaWYgKGxvY2FsaXphdGlvbiAmJiBsb2NhbGl6YXRpb24uZmFsbGJhY2spIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRMb2NhbGUgPSBsb2NhbGl6YXRpb24uZGVmYXVsdExvY2FsZSB8fCAnZW4nXG4gICAgICByZXR1cm4gbG9jYWxlID09PSBkZWZhdWx0TG9jYWxlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfSkoKVxuXG4gIC8vIEhhbmRsZSBsYWJlbGluZyBmb3IgQXJyYXlzLCBHbG9iYWwgQXJyYXlzLCBhbmQgQmxvY2tzXG4gIGNvbnN0IGdldExhYmVscyA9IChwOiBQcm9wcykgPT4ge1xuICAgIGlmIChwPy5sYWJlbHMpIHJldHVybiBwLmxhYmVsc1xuICAgIGlmIChwPy5sYWJlbCkgcmV0dXJuIHsgcGx1cmFsOiB1bmRlZmluZWQsIHNpbmd1bGFyOiBwLmxhYmVsIH1cbiAgICByZXR1cm4geyBwbHVyYWw6IHQoJ3Jvd3MnKSwgc2luZ3VsYXI6IHQoJ3JvdycpIH1cbiAgfVxuXG4gIGNvbnN0IGxhYmVscyA9IGdldExhYmVscyhwcm9wcylcblxuICBjb25zdCBtZW1vaXplZFZhbGlkYXRlID0gdXNlQ2FsbGJhY2soXG4gICAgKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAvLyBhbHRlcm5hdGl2ZSBsb2NhbGVzIGNhbiBiZSBudWxsXG4gICAgICBpZiAoIWVkaXRpbmdEZWZhdWx0TG9jYWxlICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsaWRhdGUodmFsdWUsIHsgLi4ub3B0aW9ucywgbWF4Um93cywgbWluUm93cywgcmVxdWlyZWQgfSlcbiAgICB9LFxuICAgIFttYXhSb3dzLCBtaW5Sb3dzLCByZXF1aXJlZCwgdmFsaWRhdGUsIGVkaXRpbmdEZWZhdWx0TG9jYWxlXSxcbiAgKVxuXG4gIGNvbnN0IHtcbiAgICBlcnJvck1lc3NhZ2UsXG4gICAgcm93cyA9IFtdLFxuICAgIHNob3dFcnJvcixcbiAgICB2YWxpZCxcbiAgICB2YWx1ZSxcbiAgfSA9IHVzZUZpZWxkPG51bWJlcj4oe1xuICAgIGNvbmRpdGlvbixcbiAgICBoYXNSb3dzOiB0cnVlLFxuICAgIHBhdGgsXG4gICAgdmFsaWRhdGU6IG1lbW9pemVkVmFsaWRhdGUsXG4gIH0pXG5cbiAgY29uc3QgYWRkUm93ID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHJvd0luZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIGF3YWl0IGFkZEZpZWxkUm93KHsgcGF0aCwgcm93SW5kZXggfSlcbiAgICAgIHNldE1vZGlmaWVkKHRydWUpXG5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzY3JvbGxUb0lEKGAke3BhdGh9LXJvdy0ke3Jvd0luZGV4ICsgMX1gKVxuICAgICAgfSwgMClcbiAgICB9LFxuICAgIFthZGRGaWVsZFJvdywgcGF0aCwgc2V0TW9kaWZpZWRdLFxuICApXG5cbiAgY29uc3QgZHVwbGljYXRlUm93ID0gdXNlQ2FsbGJhY2soXG4gICAgKHJvd0luZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIGRpc3BhdGNoRmllbGRzKHsgcGF0aCwgcm93SW5kZXgsIHR5cGU6ICdEVVBMSUNBVEVfUk9XJyB9KVxuICAgICAgc2V0TW9kaWZpZWQodHJ1ZSlcblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNjcm9sbFRvSUQoYCR7cGF0aH0tcm93LSR7cm93SW5kZXh9YClcbiAgICAgIH0sIDApXG4gICAgfSxcbiAgICBbZGlzcGF0Y2hGaWVsZHMsIHBhdGgsIHNldE1vZGlmaWVkXSxcbiAgKVxuXG4gIGNvbnN0IHJlbW92ZVJvdyA9IHVzZUNhbGxiYWNrKFxuICAgIChyb3dJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICByZW1vdmVGaWVsZFJvdyh7IHBhdGgsIHJvd0luZGV4IH0pXG4gICAgICBzZXRNb2RpZmllZCh0cnVlKVxuICAgIH0sXG4gICAgW3JlbW92ZUZpZWxkUm93LCBwYXRoLCBzZXRNb2RpZmllZF0sXG4gIClcblxuICBjb25zdCBtb3ZlUm93ID0gdXNlQ2FsbGJhY2soXG4gICAgKG1vdmVGcm9tSW5kZXg6IG51bWJlciwgbW92ZVRvSW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgZGlzcGF0Y2hGaWVsZHMoeyBtb3ZlRnJvbUluZGV4LCBtb3ZlVG9JbmRleCwgcGF0aCwgdHlwZTogJ01PVkVfUk9XJyB9KVxuICAgICAgc2V0TW9kaWZpZWQodHJ1ZSlcbiAgICB9LFxuICAgIFtkaXNwYXRjaEZpZWxkcywgcGF0aCwgc2V0TW9kaWZpZWRdLFxuICApXG5cbiAgY29uc3QgdG9nZ2xlQ29sbGFwc2VBbGwgPSB1c2VDYWxsYmFjayhcbiAgICAoY29sbGFwc2VkOiBib29sZWFuKSA9PiB7XG4gICAgICBkaXNwYXRjaEZpZWxkcyh7IGNvbGxhcHNlZCwgcGF0aCwgc2V0RG9jRmllbGRQcmVmZXJlbmNlcywgdHlwZTogJ1NFVF9BTExfUk9XU19DT0xMQVBTRUQnIH0pXG4gICAgfSxcbiAgICBbZGlzcGF0Y2hGaWVsZHMsIHBhdGgsIHNldERvY0ZpZWxkUHJlZmVyZW5jZXNdLFxuICApXG5cbiAgY29uc3Qgc2V0Q29sbGFwc2UgPSB1c2VDYWxsYmFjayhcbiAgICAocm93SUQ6IHN0cmluZywgY29sbGFwc2VkOiBib29sZWFuKSA9PiB7XG4gICAgICBkaXNwYXRjaEZpZWxkcyh7IGNvbGxhcHNlZCwgcGF0aCwgcm93SUQsIHNldERvY0ZpZWxkUHJlZmVyZW5jZXMsIHR5cGU6ICdTRVRfUk9XX0NPTExBUFNFRCcgfSlcbiAgICB9LFxuICAgIFtkaXNwYXRjaEZpZWxkcywgcGF0aCwgc2V0RG9jRmllbGRQcmVmZXJlbmNlc10sXG4gIClcblxuICBjb25zdCBoYXNNYXhSb3dzID0gbWF4Um93cyAmJiByb3dzLmxlbmd0aCA+PSBtYXhSb3dzXG5cbiAgY29uc3QgZmllbGRFcnJvckNvdW50ID1cbiAgICByb3dzLnJlZHVjZSgodG90YWwsIHJvdykgPT4gdG90YWwgKyAocm93Py5jaGlsZEVycm9yUGF0aHM/LnNpemUgfHwgMCksIDApICsgKHZhbGlkID8gMCA6IDEpXG5cbiAgY29uc3QgZmllbGRIYXNFcnJvcnMgPSBzdWJtaXR0ZWQgJiYgZmllbGRFcnJvckNvdW50ID4gMFxuXG4gIGNvbnN0IHNob3dSZXF1aXJlZCA9IHJlYWRPbmx5ICYmIHJvd3MubGVuZ3RoID09PSAwXG4gIGNvbnN0IHNob3dNaW5Sb3dzID0gcm93cy5sZW5ndGggPCBtaW5Sb3dzIHx8IChyZXF1aXJlZCAmJiByb3dzLmxlbmd0aCA9PT0gMClcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17W1xuICAgICAgICBmaWVsZEJhc2VDbGFzcyxcbiAgICAgICAgYmFzZUNsYXNzLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIGZpZWxkSGFzRXJyb3JzID8gYCR7YmFzZUNsYXNzfS0taGFzLWVycm9yYCA6IGAke2Jhc2VDbGFzc30tLWhhcy1uby1lcnJvcmAsXG4gICAgICBdXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oJyAnKX1cbiAgICAgIGlkPXtgZmllbGQtJHtwYXRoLnJlcGxhY2UoL1xcLi9nLCAnX18nKX1gfVxuICAgID5cbiAgICAgIHtzaG93RXJyb3IgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fZXJyb3Itd3JhcGB9PlxuICAgICAgICAgIDxFcnJvciBtZXNzYWdlPXtlcnJvck1lc3NhZ2V9IHNob3dFcnJvcj17c2hvd0Vycm9yfSAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICA8aGVhZGVyIGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9faGVhZGVyYH0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X19oZWFkZXItd3JhcGB9PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X19oZWFkZXItY29udGVudGB9PlxuICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fdGl0bGVgfT57Z2V0VHJhbnNsYXRpb24obGFiZWwgfHwgbmFtZSwgaTE4bil9PC9oMz5cbiAgICAgICAgICAgIHtmaWVsZEhhc0Vycm9ycyAmJiBmaWVsZEVycm9yQ291bnQgPiAwICYmIChcbiAgICAgICAgICAgICAgPEVycm9yUGlsbCBjb3VudD17ZmllbGRFcnJvckNvdW50fSB3aXRoTWVzc2FnZSAvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICB7cm93cy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX2hlYWRlci1hY3Rpb25zYH0+XG4gICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX2hlYWRlci1hY3Rpb25gfVxuICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gdG9nZ2xlQ29sbGFwc2VBbGwodHJ1ZSl9XG4gICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7dCgnY29sbGFwc2VBbGwnKX1cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9faGVhZGVyLWFjdGlvbmB9XG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB0b2dnbGVDb2xsYXBzZUFsbChmYWxzZSl9XG4gICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7dCgnc2hvd0FsbCcpfVxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPEZpZWxkRGVzY3JpcHRpb25cbiAgICAgICAgICBjbGFzc05hbWU9e2BmaWVsZC1kZXNjcmlwdGlvbi0ke3BhdGgucmVwbGFjZSgvXFwuL2csICdfXycpfWB9XG4gICAgICAgICAgZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufVxuICAgICAgICAgIHBhdGg9e3BhdGh9XG4gICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICAvPlxuICAgICAgPC9oZWFkZXI+XG5cbiAgICAgIDxOdWxsaWZ5TG9jYWxlRmllbGQgZmllbGRWYWx1ZT17dmFsdWV9IGxvY2FsaXplZD17bG9jYWxpemVkfSBwYXRoPXtwYXRofSAvPlxuICAgICAgeyhyb3dzLmxlbmd0aCA+IDAgfHwgKCF2YWxpZCAmJiAoc2hvd1JlcXVpcmVkIHx8IHNob3dNaW5Sb3dzKSkpICYmIChcbiAgICAgICAgPERyYWdnYWJsZVNvcnRhYmxlXG4gICAgICAgICAgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X19kcmFnZ2FibGUtcm93c2B9XG4gICAgICAgICAgaWRzPXtyb3dzLm1hcCgocm93KSA9PiByb3cuaWQpfVxuICAgICAgICAgIG9uRHJhZ0VuZD17KHsgbW92ZUZyb21JbmRleCwgbW92ZVRvSW5kZXggfSkgPT4gbW92ZVJvdyhtb3ZlRnJvbUluZGV4LCBtb3ZlVG9JbmRleCl9XG4gICAgICAgID5cbiAgICAgICAgICB7cm93cy5tYXAoKHJvdywgaSkgPT4gKFxuICAgICAgICAgICAgPERyYWdnYWJsZVNvcnRhYmxlSXRlbSBkaXNhYmxlZD17cmVhZE9ubHl9IGlkPXtyb3cuaWR9IGtleT17cm93LmlkfT5cbiAgICAgICAgICAgICAgeyhkcmFnZ2FibGVTb3J0YWJsZUl0ZW1Qcm9wcykgPT4gKFxuICAgICAgICAgICAgICAgIDxBcnJheVJvd1xuICAgICAgICAgICAgICAgICAgey4uLmRyYWdnYWJsZVNvcnRhYmxlSXRlbVByb3BzfVxuICAgICAgICAgICAgICAgICAgQ3VzdG9tUm93TGFiZWw9e0N1c3RvbVJvd0xhYmVsfVxuICAgICAgICAgICAgICAgICAgYWRkUm93PXthZGRSb3d9XG4gICAgICAgICAgICAgICAgICBkdXBsaWNhdGVSb3c9e2R1cGxpY2F0ZVJvd31cbiAgICAgICAgICAgICAgICAgIGZpZWxkVHlwZXM9e2ZpZWxkVHlwZXN9XG4gICAgICAgICAgICAgICAgICBmaWVsZHM9e2ZpZWxkc31cbiAgICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyPXtmb3JjZVJlbmRlcn1cbiAgICAgICAgICAgICAgICAgIGhhc01heFJvd3M9e2hhc01heFJvd3N9XG4gICAgICAgICAgICAgICAgICBpbmRleFBhdGg9e2luZGV4UGF0aH1cbiAgICAgICAgICAgICAgICAgIGxhYmVscz17bGFiZWxzfVxuICAgICAgICAgICAgICAgICAgbW92ZVJvdz17bW92ZVJvd31cbiAgICAgICAgICAgICAgICAgIHBhdGg9e3BhdGh9XG4gICAgICAgICAgICAgICAgICBwZXJtaXNzaW9ucz17cGVybWlzc2lvbnN9XG4gICAgICAgICAgICAgICAgICByZWFkT25seT17cmVhZE9ubHl9XG4gICAgICAgICAgICAgICAgICByZW1vdmVSb3c9e3JlbW92ZVJvd31cbiAgICAgICAgICAgICAgICAgIHJvdz17cm93fVxuICAgICAgICAgICAgICAgICAgcm93Q291bnQ9e3Jvd3MubGVuZ3RofVxuICAgICAgICAgICAgICAgICAgcm93SW5kZXg9e2l9XG4gICAgICAgICAgICAgICAgICBzZXRDb2xsYXBzZT17c2V0Q29sbGFwc2V9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvRHJhZ2dhYmxlU29ydGFibGVJdGVtPlxuICAgICAgICAgICkpfVxuICAgICAgICAgIHshdmFsaWQgJiYgKFxuICAgICAgICAgICAgPFJlYWN0LkZyYWdtZW50PlxuICAgICAgICAgICAgICB7c2hvd1JlcXVpcmVkICYmIChcbiAgICAgICAgICAgICAgICA8QmFubmVyPlxuICAgICAgICAgICAgICAgICAge3QoJ3ZhbGlkYXRpb246ZmllbGRIYXNObycsIHsgbGFiZWw6IGdldFRyYW5zbGF0aW9uKGxhYmVscy5wbHVyYWwsIGkxOG4pIH0pfVxuICAgICAgICAgICAgICAgIDwvQmFubmVyPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICB7c2hvd01pblJvd3MgJiYgKFxuICAgICAgICAgICAgICAgIDxCYW5uZXIgdHlwZT1cImVycm9yXCI+XG4gICAgICAgICAgICAgICAgICB7dCgndmFsaWRhdGlvbjpyZXF1aXJlc0F0TGVhc3QnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBtaW5Sb3dzLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDpcbiAgICAgICAgICAgICAgICAgICAgICBnZXRUcmFuc2xhdGlvbihtaW5Sb3dzID8gbGFiZWxzLnBsdXJhbCA6IGxhYmVscy5zaW5ndWxhciwgaTE4bikgfHxcbiAgICAgICAgICAgICAgICAgICAgICB0KG1pblJvd3MgPiAxID8gJ2dlbmVyYWw6cm93JyA6ICdnZW5lcmFsOnJvd3MnKSxcbiAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgIDwvQmFubmVyPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9SZWFjdC5GcmFnbWVudD5cbiAgICAgICAgICApfVxuICAgICAgICA8L0RyYWdnYWJsZVNvcnRhYmxlPlxuICAgICAgKX1cbiAgICAgIHshcmVhZE9ubHkgJiYgIWhhc01heFJvd3MgJiYgKFxuICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgYnV0dG9uU3R5bGU9XCJpY29uLWxhYmVsXCJcbiAgICAgICAgICBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX2FkZC1yb3dgfVxuICAgICAgICAgIGljb249XCJwbHVzXCJcbiAgICAgICAgICBpY29uUG9zaXRpb249XCJsZWZ0XCJcbiAgICAgICAgICBpY29uU3R5bGU9XCJ3aXRoLWJvcmRlclwiXG4gICAgICAgICAgb25DbGljaz17KCkgPT4gYWRkUm93KHZhbHVlIHx8IDApfVxuICAgICAgICA+XG4gICAgICAgICAge3QoJ2FkZExhYmVsJywgeyBsYWJlbDogZ2V0VHJhbnNsYXRpb24obGFiZWxzLnNpbmd1bGFyLCBpMThuKSB9KX1cbiAgICAgICAgPC9CdXR0b24+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhDb25kaXRpb24oQXJyYXlGaWVsZFR5cGUpXG4iXSwibmFtZXMiOlsiYmFzZUNsYXNzIiwiQXJyYXlGaWVsZFR5cGUiLCJwcm9wcyIsIm5hbWUiLCJhZG1pbiIsImNsYXNzTmFtZSIsImNvbXBvbmVudHMiLCJjb25kaXRpb24iLCJkZXNjcmlwdGlvbiIsInJlYWRPbmx5IiwiZmllbGRUeXBlcyIsImZpZWxkcyIsImZvcmNlUmVuZGVyIiwiaW5kZXhQYXRoIiwibG9jYWxpemVkIiwibWF4Um93cyIsIm1pblJvd3MiLCJwYXRoIiwicGF0aEZyb21Qcm9wcyIsInBlcm1pc3Npb25zIiwicmVxdWlyZWQiLCJ2YWxpZGF0ZSIsImFycmF5IiwibGFiZWwiLCJsYWJlbHMiLCJzaW5ndWxhciIsIkN1c3RvbVJvd0xhYmVsIiwiUm93TGFiZWwiLCJ1bmRlZmluZWQiLCJzZXREb2NGaWVsZFByZWZlcmVuY2VzIiwidXNlRG9jdW1lbnRJbmZvIiwiYWRkRmllbGRSb3ciLCJkaXNwYXRjaEZpZWxkcyIsInJlbW92ZUZpZWxkUm93Iiwic2V0TW9kaWZpZWQiLCJ1c2VGb3JtIiwic3VibWl0dGVkIiwidXNlRm9ybVN1Ym1pdHRlZCIsImNvZGUiLCJsb2NhbGUiLCJ1c2VMb2NhbGUiLCJpMThuIiwidCIsInVzZVRyYW5zbGF0aW9uIiwibG9jYWxpemF0aW9uIiwidXNlQ29uZmlnIiwiZWRpdGluZ0RlZmF1bHRMb2NhbGUiLCJmYWxsYmFjayIsImRlZmF1bHRMb2NhbGUiLCJnZXRMYWJlbHMiLCJwIiwicGx1cmFsIiwibWVtb2l6ZWRWYWxpZGF0ZSIsInVzZUNhbGxiYWNrIiwidmFsdWUiLCJvcHRpb25zIiwiZXJyb3JNZXNzYWdlIiwicm93cyIsInNob3dFcnJvciIsInZhbGlkIiwidXNlRmllbGQiLCJoYXNSb3dzIiwiYWRkUm93Iiwicm93SW5kZXgiLCJzZXRUaW1lb3V0Iiwic2Nyb2xsVG9JRCIsImR1cGxpY2F0ZVJvdyIsInR5cGUiLCJyZW1vdmVSb3ciLCJtb3ZlUm93IiwibW92ZUZyb21JbmRleCIsIm1vdmVUb0luZGV4IiwidG9nZ2xlQ29sbGFwc2VBbGwiLCJjb2xsYXBzZWQiLCJzZXRDb2xsYXBzZSIsInJvd0lEIiwiaGFzTWF4Um93cyIsImxlbmd0aCIsImZpZWxkRXJyb3JDb3VudCIsInJlZHVjZSIsInRvdGFsIiwicm93IiwiY2hpbGRFcnJvclBhdGhzIiwic2l6ZSIsImZpZWxkSGFzRXJyb3JzIiwic2hvd1JlcXVpcmVkIiwic2hvd01pblJvd3MiLCJkaXYiLCJmaWVsZEJhc2VDbGFzcyIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwiaWQiLCJyZXBsYWNlIiwiRXJyb3IiLCJtZXNzYWdlIiwiaGVhZGVyIiwiaDMiLCJnZXRUcmFuc2xhdGlvbiIsIkVycm9yUGlsbCIsImNvdW50Iiwid2l0aE1lc3NhZ2UiLCJ1bCIsImxpIiwiYnV0dG9uIiwib25DbGljayIsIkZpZWxkRGVzY3JpcHRpb24iLCJOdWxsaWZ5TG9jYWxlRmllbGQiLCJmaWVsZFZhbHVlIiwiRHJhZ2dhYmxlU29ydGFibGUiLCJpZHMiLCJtYXAiLCJvbkRyYWdFbmQiLCJpIiwiRHJhZ2dhYmxlU29ydGFibGVJdGVtIiwiZGlzYWJsZWQiLCJrZXkiLCJkcmFnZ2FibGVTb3J0YWJsZUl0ZW1Qcm9wcyIsIkFycmF5Um93Iiwicm93Q291bnQiLCJSZWFjdCIsIkZyYWdtZW50IiwiQmFubmVyIiwiQnV0dG9uIiwiYnV0dG9uU3R5bGUiLCJpY29uIiwiaWNvblBvc2l0aW9uIiwiaWNvblN0eWxlIiwid2l0aENvbmRpdGlvbiJdLCJtYXBwaW5ncyI6Ijs7OzsrQkFvU0E7OztlQUFBOzs7K0RBcFNtQzs4QkFDSjs2QkFJVDtnQ0FDUzs0QkFDSjsrREFDUjsrREFDQTswRUFDVzs4RUFDSTsyQkFDUjt3QkFDQTs4QkFDTTt3QkFDTjs4REFDUjt5RUFDVzt5QkFDYTs4QkFDUDtpRUFDZDtzRUFDSzt3QkFDSzswQkFDTjtRQUNsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRVAsTUFBTUEsWUFBWTtBQUVsQixNQUFNQyxpQkFBa0MsQ0FBQ0M7SUFDdkMsTUFBTSxFQUNKQyxJQUFJLEVBQ0pDLE9BQU8sRUFBRUMsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLFNBQVMsRUFBRUMsV0FBVyxFQUFFQyxRQUFRLEVBQUUsRUFDbEVDLFVBQVUsRUFDVkMsTUFBTSxFQUNOQyxjQUFjLEtBQUssRUFDbkJDLFNBQVMs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