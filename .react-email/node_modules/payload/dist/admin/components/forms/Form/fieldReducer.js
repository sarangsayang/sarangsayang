"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "fieldReducer", {
    enumerable: true,
    get: function() {
        return fieldReducer;
    }
});
const _bsonobjectid = /*#__PURE__*/ _interop_require_default(require("bson-objectid"));
const _deepequal = /*#__PURE__*/ _interop_require_default(require("deep-equal"));
const _deepCopyObject = require("../../../../utilities/deepCopyObject");
const _getSiblingData = /*#__PURE__*/ _interop_require_default(require("./getSiblingData"));
const _reduceFieldsToValues = /*#__PURE__*/ _interop_require_default(require("./reduceFieldsToValues"));
const _rows = require("./rows");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function fieldReducer(state, action) {
    switch(action.type){
        case 'REPLACE_STATE':
            {
                const newState = {};
                // Only update fields that have changed
                // by comparing old value / initialValue to new
                // ..
                // This is a performance enhancement for saving
                // large documents with hundreds of fields
                Object.entries(action.state).forEach(([path, field])=>{
                    const oldField = state[path];
                    const newField = field;
                    if (!(0, _deepequal.default)(oldField, newField)) {
                        newState[path] = newField;
                    } else if (oldField) {
                        newState[path] = oldField;
                    }
                });
                return newState;
            }
        case 'REMOVE':
            {
                const newState = {
                    ...state
                };
                if (newState[action.path]) delete newState[action.path];
                return newState;
            }
        case 'MODIFY_CONDITION':
            {
                const { path, result, user } = action;
                return Object.entries(state).reduce((newState, [fieldPath, field])=>{
                    if (fieldPath === path || fieldPath.indexOf(`${path}.`) === 0) {
                        let passesCondition = result;
                        // If a condition is being set to true,
                        // Set all conditions to true
                        // Besides those who still fail their own conditions
                        if (passesCondition && field.condition) {
                            passesCondition = Boolean(field.condition((0, _reduceFieldsToValues.default)(state, true), (0, _getSiblingData.default)(state, path), {
                                user
                            }));
                        }
                        return {
                            ...newState,
                            [fieldPath]: {
                                ...field,
                                passesCondition
                            }
                        };
                    }
                    return {
                        ...newState,
                        [fieldPath]: {
                            ...field
                        }
                    };
                }, {});
            }
        case 'UPDATE':
            {
                const newField = Object.entries(action).reduce((field, [key, value])=>{
                    if ([
                        'condition',
                        'disableFormData',
                        'errorMessage',
                        'initialValue',
                        'passesCondition',
                        'rows',
                        'valid',
                        'validate',
                        'value'
                    ].includes(key)) {
                        return {
                            ...field,
                            [key]: value
                        };
                    }
                    return field;
                }, state[action.path] || {});
                return {
                    ...state,
                    [action.path]: newField
                };
            }
        case 'REMOVE_ROW':
            {
                const { path, rowIndex } = action;
                const { remainingFields, rows } = (0, _rows.separateRows)(path, state);
                const rowsMetadata = [
                    ...state[path]?.rows || []
                ];
                rows.splice(rowIndex, 1);
                rowsMetadata.splice(rowIndex, 1);
                const newState = {
                    ...remainingFields,
                    [path]: {
                        ...state[path],
                        disableFormData: rows.length > 0,
                        rows: rowsMetadata,
                        value: rows.length
                    },
                    ...(0, _rows.flattenRows)(path, rows)
                };
                return newState;
            }
        case 'ADD_ROW':
            {
                const { blockType, path, rowIndex: rowIndexFromArgs, subFieldState } = action;
                const rowIndex = typeof rowIndexFromArgs === 'number' ? rowIndexFromArgs : state[path]?.rows?.length || 0;
                const rowsMetadata = [
                    ...state[path]?.rows || []
                ];
                rowsMetadata.splice(rowIndex, 0, // new row
                {
                    id: new _bsonobjectid.default().toHexString(),
                    blockType: blockType || undefined,
                    childErrorPaths: new Set(),
                    collapsed: false
                });
                if (blockType) {
                    subFieldState.blockType = {
                        initialValue: blockType,
                        valid: true,
                        value: blockType
                    };
                }
                // add new row to array _field state_
                const { remainingFields, rows: siblingRows } = (0, _rows.separateRows)(path, state);
                siblingRows.splice(rowIndex, 0, subFieldState);
                const newState = {
                    ...remainingFields,
                    ...(0, _rows.flattenRows)(path, siblingRows),
                    [path]: {
                        ...state[path],
                        disableFormData: true,
                        rows: rowsMetadata,
                        value: siblingRows.length
                    }
                };
                return newState;
            }
        case 'REPLACE_ROW':
            {
                const { blockType, path, rowIndex: rowIndexArg, subFieldState } = action;
                const { remainingFields, rows: siblingRows } = (0, _rows.separateRows)(path, state);
                const rowIndex = Math.max(0, Math.min(rowIndexArg, siblingRows?.length - 1 || 0));
                const rowsMetadata = [
                    ...state[path]?.rows || []
                ];
                rowsMetadata[rowIndex] = {
                    id: new _bsonobjectid.default().toHexString(),
                    blockType: blockType || undefined,
                    childErrorPaths: new Set(),
                    collapsed: false
                };
                if (blockType) {
                    subFieldState.blockType = {
                        initialValue: blockType,
                        valid: true,
                        value: blockType
                    };
                }
                // replace form _field state_
                siblingRows[rowIndex] = subFieldState;
                const newState = {
                    ...remainingFields,
                    ...(0, _rows.flattenRows)(path, siblingRows),
                    [path]: {
                        ...state[path],
                        disableFormData: true,
                        rows: rowsMetadata,
                        value: siblingRows.length
                    }
                };
                return newState;
            }
        case 'DUPLICATE_ROW':
            {
                const { path, rowIndex } = action;
                const { remainingFields, rows } = (0, _rows.separateRows)(path, state);
                const rowsMetadata = state[path]?.rows || [];
                const duplicateRowMetadata = (0, _deepCopyObject.deepCopyObject)(rowsMetadata[rowIndex]);
                if (duplicateRowMetadata.id) duplicateRowMetadata.id = new _bsonobjectid.default().toHexString();
                const duplicateRowState = (0, _deepCopyObject.deepCopyObject)(rows[rowIndex]);
                if (duplicateRowState.id) duplicateRowState.id = new _bsonobjectid.default().toHexString();
                // If there are subfields
                if (Object.keys(duplicateRowState).length > 0) {
                    // Add new object containing subfield names to unflattenedRows array
                    rows.splice(rowIndex + 1, 0, duplicateRowState);
                    rowsMetadata.splice(rowIndex + 1, 0, duplicateRowMetadata);
                }
                const newState = {
                    ...remainingFields,
                    [path]: {
                        ...state[path],
                        disableFormData: true,
                        rows: rowsMetadata,
                        value: rows.length
                    },
                    ...(0, _rows.flattenRows)(path, rows)
                };
                return newState;
            }
        case 'MOVE_ROW':
            {
                const { moveFromIndex, moveToIndex, path } = action;
                const { remainingFields, rows } = (0, _rows.separateRows)(path, state);
                // copy the row to move
                const copyOfMovingRow = rows[moveFromIndex];
                // delete the row by index
                rows.splice(moveFromIndex, 1);
                // insert row copyOfMovingRow back in
                rows.splice(moveToIndex, 0, copyOfMovingRow);
                // modify array/block internal row state (i.e. collapsed, blockType)
                const rowStateCopy = [
                    ...state[path]?.rows || []
                ];
                const movingRowState = {
                    ...rowStateCopy[moveFromIndex]
                };
                rowStateCopy.splice(moveFromIndex, 1);
                rowStateCopy.splice(moveToIndex, 0, movingRowState);
                const newState = {
                    ...remainingFields,
                    ...(0, _rows.flattenRows)(path, rows),
                    [path]: {
                        ...state[path],
                        rows: rowStateCopy
                    }
                };
                return newState;
            }
        case 'SET_ROW_COLLAPSED':
            {
                const { collapsed, path, rowID, setDocFieldPreferences } = action;
                const arrayState = state[path];
                const { collapsedRowIDs, matchedIndex } = state[path].rows.reduce((acc, row, index)=>{
                    const isMatchingRow = row.id === rowID;
                    if (isMatchingRow) acc.matchedIndex = index;
                    if (!isMatchingRow && row.collapsed) acc.collapsedRowIDs.push(row.id);
                    else if (isMatchingRow && collapsed) acc.collapsedRowIDs.push(row.id);
                    return acc;
                }, {
                    collapsedRowIDs: [],
                    matchedIndex: undefined
                });
                if (matchedIndex > -1) {
                    arrayState.rows[matchedIndex].collapsed = collapsed;
                    setDocFieldPreferences(path, {
                        collapsed: collapsedRowIDs
                    });
                }
                const newState = {
                    ...state,
                    [path]: {
                        ...arrayState
                    }
                };
                return newState;
            }
        case 'SET_ALL_ROWS_COLLAPSED':
            {
                const { collapsed, path, setDocFieldPreferences } = action;
                const { collapsedRowIDs, rows } = state[path].rows.reduce((acc, row)=>{
                    if (collapsed) acc.collapsedRowIDs.push(row.id);
                    acc.rows.push({
                        ...row,
                        collapsed
                    });
                    return acc;
                }, {
                    collapsedRowIDs: [],
                    rows: []
                });
                setDocFieldPreferences(path, {
                    collapsed: collapsedRowIDs
                });
                return {
                    ...state,
                    [path]: {
                        ...state[path],
                        rows
                    }
                };
            }
        default:
            {
                return state;
            }
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2Zvcm1zL0Zvcm0vZmllbGRSZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBPYmplY3RJRCBmcm9tICdic29uLW9iamVjdGlkJ1xuaW1wb3J0IGVxdWFsIGZyb20gJ2RlZXAtZXF1YWwnXG5cbmltcG9ydCB0eXBlIHsgRmllbGRBY3Rpb24sIEZpZWxkcywgRm9ybUZpZWxkIH0gZnJvbSAnLi90eXBlcydcblxuaW1wb3J0IHsgZGVlcENvcHlPYmplY3QgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlsaXRpZXMvZGVlcENvcHlPYmplY3QnXG5pbXBvcnQgZ2V0U2libGluZ0RhdGEgZnJvbSAnLi9nZXRTaWJsaW5nRGF0YSdcbmltcG9ydCByZWR1Y2VGaWVsZHNUb1ZhbHVlcyBmcm9tICcuL3JlZHVjZUZpZWxkc1RvVmFsdWVzJ1xuaW1wb3J0IHsgZmxhdHRlblJvd3MsIHNlcGFyYXRlUm93cyB9IGZyb20gJy4vcm93cydcblxuLyoqXG4gKiBSZWR1Y2VyIHdoaWNoIG1vZGlmaWVzIHRoZSBmb3JtIGZpZWxkIHN0YXRlIChhbGwgdGhlIGN1cnJlbnQgZGF0YSBvZiB0aGUgZmllbGRzIGluIHRoZSBmb3JtKS4gV2hlbiBjYWxsZWQgdXNpbmcgZGlzcGF0Y2gsIGl0IHdpbGwgcmV0dXJuIGEgbmV3IHN0YXRlIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpZWxkUmVkdWNlcihzdGF0ZTogRmllbGRzLCBhY3Rpb246IEZpZWxkQWN0aW9uKTogRmllbGRzIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ1JFUExBQ0VfU1RBVEUnOiB7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHt9XG5cbiAgICAgIC8vIE9ubHkgdXBkYXRlIGZpZWxkcyB0aGF0IGhhdmUgY2hhbmdlZFxuICAgICAgLy8gYnkgY29tcGFyaW5nIG9sZCB2YWx1ZSAvIGluaXRpYWxWYWx1ZSB0byBuZXdcbiAgICAgIC8vIC4uXG4gICAgICAvLyBUaGlzIGlzIGEgcGVyZm9ybWFuY2UgZW5oYW5jZW1lbnQgZm9yIHNhdmluZ1xuICAgICAgLy8gbGFyZ2UgZG9jdW1lbnRzIHdpdGggaHVuZHJlZHMgb2YgZmllbGRzXG5cbiAgICAgIE9iamVjdC5lbnRyaWVzKGFjdGlvbi5zdGF0ZSkuZm9yRWFjaCgoW3BhdGgsIGZpZWxkXSkgPT4ge1xuICAgICAgICBjb25zdCBvbGRGaWVsZCA9IHN0YXRlW3BhdGhdXG4gICAgICAgIGNvbnN0IG5ld0ZpZWxkID0gZmllbGRcblxuICAgICAgICBpZiAoIWVxdWFsKG9sZEZpZWxkLCBuZXdGaWVsZCkpIHtcbiAgICAgICAgICBuZXdTdGF0ZVtwYXRoXSA9IG5ld0ZpZWxkXG4gICAgICAgIH0gZWxzZSBpZiAob2xkRmllbGQpIHtcbiAgICAgICAgICBuZXdTdGF0ZVtwYXRoXSA9IG9sZEZpZWxkXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiBuZXdTdGF0ZVxuICAgIH1cblxuICAgIGNhc2UgJ1JFTU9WRSc6IHtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0geyAuLi5zdGF0ZSB9XG4gICAgICBpZiAobmV3U3RhdGVbYWN0aW9uLnBhdGhdKSBkZWxldGUgbmV3U3RhdGVbYWN0aW9uLnBhdGhdXG4gICAgICByZXR1cm4gbmV3U3RhdGVcbiAgICB9XG5cbiAgICBjYXNlICdNT0RJRllfQ09ORElUSU9OJzoge1xuICAgICAgY29uc3QgeyBwYXRoLCByZXN1bHQsIHVzZXIgfSA9IGFjdGlvblxuXG4gICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoc3RhdGUpLnJlZHVjZSgobmV3U3RhdGUsIFtmaWVsZFBhdGgsIGZpZWxkXSkgPT4ge1xuICAgICAgICBpZiAoZmllbGRQYXRoID09PSBwYXRoIHx8IGZpZWxkUGF0aC5pbmRleE9mKGAke3BhdGh9LmApID09PSAwKSB7XG4gICAgICAgICAgbGV0IHBhc3Nlc0NvbmRpdGlvbiA9IHJlc3VsdFxuXG4gICAgICAgICAgLy8gSWYgYSBjb25kaXRpb24gaXMgYmVpbmcgc2V0IHRvIHRydWUsXG4gICAgICAgICAgLy8gU2V0IGFsbCBjb25kaXRpb25zIHRvIHRydWVcbiAgICAgICAgICAvLyBCZXNpZGVzIHRob3NlIHdobyBzdGlsbCBmYWlsIHRoZWlyIG93biBjb25kaXRpb25zXG5cbiAgICAgICAgICBpZiAocGFzc2VzQ29uZGl0aW9uICYmIGZpZWxkLmNvbmRpdGlvbikge1xuICAgICAgICAgICAgcGFzc2VzQ29uZGl0aW9uID0gQm9vbGVhbihcbiAgICAgICAgICAgICAgZmllbGQuY29uZGl0aW9uKHJlZHVjZUZpZWxkc1RvVmFsdWVzKHN0YXRlLCB0cnVlKSwgZ2V0U2libGluZ0RhdGEoc3RhdGUsIHBhdGgpLCB7XG4gICAgICAgICAgICAgICAgdXNlcixcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICAgICAgW2ZpZWxkUGF0aF06IHtcbiAgICAgICAgICAgICAgLi4uZmllbGQsXG4gICAgICAgICAgICAgIHBhc3Nlc0NvbmRpdGlvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5uZXdTdGF0ZSxcbiAgICAgICAgICBbZmllbGRQYXRoXToge1xuICAgICAgICAgICAgLi4uZmllbGQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgfSwge30pXG4gICAgfVxuXG4gICAgY2FzZSAnVVBEQVRFJzoge1xuICAgICAgY29uc3QgbmV3RmllbGQgPSBPYmplY3QuZW50cmllcyhhY3Rpb24pLnJlZHVjZShcbiAgICAgICAgKGZpZWxkLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdjb25kaXRpb24nLFxuICAgICAgICAgICAgICAnZGlzYWJsZUZvcm1EYXRhJyxcbiAgICAgICAgICAgICAgJ2Vycm9yTWVzc2FnZScsXG4gICAgICAgICAgICAgICdpbml0aWFsVmFsdWUnLFxuICAgICAgICAgICAgICAncGFzc2VzQ29uZGl0aW9uJyxcbiAgICAgICAgICAgICAgJ3Jvd3MnLFxuICAgICAgICAgICAgICAndmFsaWQnLFxuICAgICAgICAgICAgICAndmFsaWRhdGUnLFxuICAgICAgICAgICAgICAndmFsdWUnLFxuICAgICAgICAgICAgXS5pbmNsdWRlcyhrZXkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5maWVsZCxcbiAgICAgICAgICAgICAgW2tleV06IHZhbHVlLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmaWVsZFxuICAgICAgICB9LFxuICAgICAgICBzdGF0ZVthY3Rpb24ucGF0aF0gfHwgKHt9IGFzIEZvcm1GaWVsZCksXG4gICAgICApXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBbYWN0aW9uLnBhdGhdOiBuZXdGaWVsZCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYXNlICdSRU1PVkVfUk9XJzoge1xuICAgICAgY29uc3QgeyBwYXRoLCByb3dJbmRleCB9ID0gYWN0aW9uXG4gICAgICBjb25zdCB7IHJlbWFpbmluZ0ZpZWxkcywgcm93cyB9ID0gc2VwYXJhdGVSb3dzKHBhdGgsIHN0YXRlKVxuICAgICAgY29uc3Qgcm93c01ldGFkYXRhID0gWy4uLihzdGF0ZVtwYXRoXT8ucm93cyB8fCBbXSldXG5cbiAgICAgIHJvd3Muc3BsaWNlKHJvd0luZGV4LCAxKVxuICAgICAgcm93c01ldGFkYXRhLnNwbGljZShyb3dJbmRleCwgMSlcblxuICAgICAgY29uc3QgbmV3U3RhdGU6IEZpZWxkcyA9IHtcbiAgICAgICAgLi4ucmVtYWluaW5nRmllbGRzLFxuICAgICAgICBbcGF0aF06IHtcbiAgICAgICAgICAuLi5zdGF0ZVtwYXRoXSxcbiAgICAgICAgICBkaXNhYmxlRm9ybURhdGE6IHJvd3MubGVuZ3RoID4gMCxcbiAgICAgICAgICByb3dzOiByb3dzTWV0YWRhdGEsXG4gICAgICAgICAgdmFsdWU6IHJvd3MubGVuZ3RoLFxuICAgICAgICB9LFxuICAgICAgICAuLi5mbGF0dGVuUm93cyhwYXRoLCByb3dzKSxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1N0YXRlXG4gICAgfVxuXG4gICAgY2FzZSAnQUREX1JPVyc6IHtcbiAgICAgIGNvbnN0IHsgYmxvY2tUeXBlLCBwYXRoLCByb3dJbmRleDogcm93SW5kZXhGcm9tQXJncywgc3ViRmllbGRTdGF0ZSB9ID0gYWN0aW9uXG4gICAgICBjb25zdCByb3dJbmRleCA9XG4gICAgICAgIHR5cGVvZiByb3dJbmRleEZyb21BcmdzID09PSAnbnVtYmVyJyA/IHJvd0luZGV4RnJvbUFyZ3MgOiBzdGF0ZVtwYXRoXT8ucm93cz8ubGVuZ3RoIHx8IDBcblxuICAgICAgY29uc3Qgcm93c01ldGFkYXRhID0gWy4uLihzdGF0ZVtwYXRoXT8ucm93cyB8fCBbXSldXG4gICAgICByb3dzTWV0YWRhdGEuc3BsaWNlKFxuICAgICAgICByb3dJbmRleCxcbiAgICAgICAgMCxcbiAgICAgICAgLy8gbmV3IHJvd1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6IG5ldyBPYmplY3RJRCgpLnRvSGV4U3RyaW5nKCksXG4gICAgICAgICAgYmxvY2tUeXBlOiBibG9ja1R5cGUgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIGNoaWxkRXJyb3JQYXRoczogbmV3IFNldCgpLFxuICAgICAgICAgIGNvbGxhcHNlZDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICApXG5cbiAgICAgIGlmIChibG9ja1R5cGUpIHtcbiAgICAgICAgc3ViRmllbGRTdGF0ZS5ibG9ja1R5cGUgPSB7XG4gICAgICAgICAgaW5pdGlhbFZhbHVlOiBibG9ja1R5cGUsXG4gICAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IGJsb2NrVHlwZSxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBhZGQgbmV3IHJvdyB0byBhcnJheSBfZmllbGQgc3RhdGVfXG4gICAgICBjb25zdCB7IHJlbWFpbmluZ0ZpZWxkcywgcm93czogc2libGluZ1Jvd3MgfSA9IHNlcGFyYXRlUm93cyhwYXRoLCBzdGF0ZSlcbiAgICAgIHNpYmxpbmdSb3dzLnNwbGljZShyb3dJbmRleCwgMCwgc3ViRmllbGRTdGF0ZSlcblxuICAgICAgY29uc3QgbmV3U3RhdGU6IEZpZWxkcyA9IHtcbiAgICAgICAgLi4ucmVtYWluaW5nRmllbGRzLFxuICAgICAgICAuLi5mbGF0dGVuUm93cyhwYXRoLCBzaWJsaW5nUm93cyksXG4gICAgICAgIFtwYXRoXToge1xuICAgICAgICAgIC4uLnN0YXRlW3BhdGhdLFxuICAgICAgICAgIGRpc2FibGVGb3JtRGF0YTogdHJ1ZSxcbiAgICAgICAgICByb3dzOiByb3dzTWV0YWRhdGEsXG4gICAgICAgICAgdmFsdWU6IHNpYmxpbmdSb3dzLmxlbmd0aCxcbiAgICAgICAgfSxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1N0YXRlXG4gICAgfVxuXG4gICAgY2FzZSAnUkVQTEFDRV9ST1cnOiB7XG4gICAgICBjb25zdCB7IGJsb2NrVHlwZSwgcGF0aCwgcm93SW5kZXg6IHJvd0luZGV4QXJnLCBzdWJGaWVsZFN0YXRlIH0gPSBhY3Rpb25cbiAgICAgIGNvbnN0IHsgcmVtYWluaW5nRmllbGRzLCByb3dzOiBzaWJsaW5nUm93cyB9ID0gc2VwYXJhdGVSb3dzKHBhdGgsIHN0YXRlKVxuICAgICAgY29uc3Qgcm93SW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyb3dJbmRleEFyZywgc2libGluZ1Jvd3M/Lmxlbmd0aCAtIDEgfHwgMCkpXG5cbiAgICAgIGNvbnN0IHJvd3NNZXRhZGF0YSA9IFsuLi4oc3RhdGVbcGF0aF0/LnJvd3MgfHwgW10pXVxuICAgICAgcm93c01ldGFkYXRhW3Jvd0luZGV4XSA9IHtcbiAgICAgICAgaWQ6IG5ldyBPYmplY3RJRCgpLnRvSGV4U3RyaW5nKCksXG4gICAgICAgIGJsb2NrVHlwZTogYmxvY2tUeXBlIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgY2hpbGRFcnJvclBhdGhzOiBuZXcgU2V0KCksXG4gICAgICAgIGNvbGxhcHNlZDogZmFsc2UsXG4gICAgICB9XG5cbiAgICAgIGlmIChibG9ja1R5cGUpIHtcbiAgICAgICAgc3ViRmllbGRTdGF0ZS5ibG9ja1R5cGUgPSB7XG4gICAgICAgICAgaW5pdGlhbFZhbHVlOiBibG9ja1R5cGUsXG4gICAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IGJsb2NrVHlwZSxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyByZXBsYWNlIGZvcm0gX2ZpZWxkIHN0YXRlX1xuICAgICAgc2libGluZ1Jvd3Nbcm93SW5kZXhdID0gc3ViRmllbGRTdGF0ZVxuXG4gICAgICBjb25zdCBuZXdTdGF0ZTogRmllbGRzID0ge1xuICAgICAgICAuLi5yZW1haW5pbmdGaWVsZHMsXG4gICAgICAgIC4uLmZsYXR0ZW5Sb3dzKHBhdGgsIHNpYmxpbmdSb3dzKSxcbiAgICAgICAgW3BhdGhdOiB7XG4gICAgICAgICAgLi4uc3RhdGVbcGF0aF0sXG4gICAgICAgICAgZGlzYWJsZUZvcm1EYXRhOiB0cnVlLFxuICAgICAgICAgIHJvd3M6IHJvd3NNZXRhZGF0YSxcbiAgICAgICAgICB2YWx1ZTogc2libGluZ1Jvd3MubGVuZ3RoLFxuICAgICAgICB9LFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3U3RhdGVcbiAgICB9XG5cbiAgICBjYXNlICdEVVBMSUNBVEVfUk9XJzoge1xuICAgICAgY29uc3QgeyBwYXRoLCByb3dJbmRleCB9ID0gYWN0aW9uXG4gICAgICBjb25zdCB7IHJlbWFpbmluZ0ZpZWxkcywgcm93cyB9ID0gc2VwYXJhdGVSb3dzKHBhdGgsIHN0YXRlKVxuICAgICAgY29uc3Qgcm93c01ldGFkYXRhID0gc3RhdGVbcGF0aF0/LnJvd3MgfHwgW11cblxuICAgICAgY29uc3QgZHVwbGljYXRlUm93TWV0YWRhdGEgPSBkZWVwQ29weU9iamVjdChyb3dzTWV0YWRhdGFbcm93SW5kZXhdKVxuICAgICAgaWYgKGR1cGxpY2F0ZVJvd01ldGFkYXRhLmlkKSBkdXBsaWNhdGVSb3dNZXRhZGF0YS5pZCA9IG5ldyBPYmplY3RJRCgpLnRvSGV4U3RyaW5nKClcblxuICAgICAgY29uc3QgZHVwbGljYXRlUm93U3RhdGUgPSBkZWVwQ29weU9iamVjdChyb3dzW3Jvd0luZGV4XSlcbiAgICAgIGlmIChkdXBsaWNhdGVSb3dTdGF0ZS5pZCkgZHVwbGljYXRlUm93U3RhdGUuaWQgPSBuZXcgT2JqZWN0SUQoKS50b0hleFN0cmluZygpXG5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSBzdWJmaWVsZHNcbiAgICAgIGlmIChPYmplY3Qua2V5cyhkdXBsaWNhdGVSb3dTdGF0ZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBBZGQgbmV3IG9iamVjdCBjb250YWluaW5nIHN1YmZpZWxkIG5hbWVzIHRvIHVuZmxhdHRlbmVkUm93cyBhcnJheVxuICAgICAgICByb3dzLnNwbGljZShyb3dJbmRleCArIDEsIDAsIGR1cGxpY2F0ZVJvd1N0YXRlKVxuICAgICAgICByb3dzTWV0YWRhdGEuc3BsaWNlKHJvd0luZGV4ICsgMSwgMCwgZHVwbGljYXRlUm93TWV0YWRhdGEpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgICAuLi5yZW1haW5pbmdGaWVsZHMsXG4gICAgICAgIFtwYXRoXToge1xuICAgICAgICAgIC4uLnN0YXRlW3BhdGhdLFxuICAgICAgICAgIGRpc2FibGVGb3JtRGF0YTogdHJ1ZSxcbiAgICAgICAgICByb3dzOiByb3dzTWV0YWRhdGEsXG4gICAgICAgICAgdmFsdWU6IHJvd3MubGVuZ3RoLFxuICAgICAgICB9LFxuICAgICAgICAuLi5mbGF0dGVuUm93cyhwYXRoLCByb3dzKSxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1N0YXRlXG4gICAgfVxuXG4gICAgY2FzZSAnTU9WRV9ST1cnOiB7XG4gICAgICBjb25zdCB7IG1vdmVGcm9tSW5kZXgsIG1vdmVUb0luZGV4LCBwYXRoIH0gPSBhY3Rpb25cbiAgICAgIGNvbnN0IHsgcmVtYWluaW5nRmllbGRzLCByb3dzIH0gPSBzZXBhcmF0ZVJvd3MocGF0aCwgc3RhdGUpXG5cbiAgICAgIC8vIGNvcHkgdGhlIHJvdyB0byBtb3ZlXG4gICAgICBjb25zdCBjb3B5T2ZNb3ZpbmdSb3cgPSByb3dzW21vdmVGcm9tSW5kZXhdXG4gICAgICAvLyBkZWxldGUgdGhlIHJvdyBieSBpbmRleFxuICAgICAgcm93cy5zcGxpY2UobW92ZUZyb21JbmRleCwgMSlcbiAgICAgIC8vIGluc2VydCByb3cgY29weU9mTW92aW5nUm93IGJhY2sgaW5cbiAgICAgIHJvd3Muc3BsaWNlKG1vdmVUb0luZGV4LCAwLCBjb3B5T2ZNb3ZpbmdSb3cpXG5cbiAgICAgIC8vIG1vZGlmeSBhcnJheS9ibG9jayBpbnRlcm5hbCByb3cgc3RhdGUgKGkuZS4gY29sbGFwc2VkLCBibG9ja1R5cGUpXG4gICAgICBjb25zdCByb3dTdGF0ZUNvcHkgPSBbLi4uKHN0YXRlW3BhdGhdPy5yb3dzIHx8IFtdKV1cbiAgICAgIGNvbnN0IG1vdmluZ1Jvd1N0YXRlID0geyAuLi5yb3dTdGF0ZUNvcHlbbW92ZUZyb21JbmRleF0gfVxuICAgICAgcm93U3RhdGVDb3B5LnNwbGljZShtb3ZlRnJvbUluZGV4LCAxKVxuICAgICAgcm93U3RhdGVDb3B5LnNwbGljZShtb3ZlVG9JbmRleCwgMCwgbW92aW5nUm93U3RhdGUpXG5cbiAgICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgICAuLi5yZW1haW5pbmdGaWVsZHMsXG4gICAgICAgIC4uLmZsYXR0ZW5Sb3dzKHBhdGgsIHJvd3MpLFxuICAgICAgICBbcGF0aF06IHtcbiAgICAgICAgICAuLi5zdGF0ZVtwYXRoXSxcbiAgICAgICAgICByb3dzOiByb3dTdGF0ZUNvcHksXG4gICAgICAgIH0sXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdTdGF0ZVxuICAgIH1cblxuICAgIGNhc2UgJ1NFVF9ST1dfQ09MTEFQU0VEJzoge1xuICAgICAgY29uc3QgeyBjb2xsYXBzZWQsIHBhdGgsIHJvd0lELCBzZXREb2NGaWVsZFByZWZlcmVuY2VzIH0gPSBhY3Rpb25cblxuICAgICAgY29uc3QgYXJyYXlTdGF0ZSA9IHN0YXRlW3BhdGhdXG5cbiAgICAgIGNvbnN0IHsgY29sbGFwc2VkUm93SURzLCBtYXRjaGVkSW5kZXggfSA9IHN0YXRlW3BhdGhdLnJvd3MucmVkdWNlKFxuICAgICAgICAoYWNjLCByb3csIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgaXNNYXRjaGluZ1JvdyA9IHJvdy5pZCA9PT0gcm93SURcbiAgICAgICAgICBpZiAoaXNNYXRjaGluZ1JvdykgYWNjLm1hdGNoZWRJbmRleCA9IGluZGV4XG5cbiAgICAgICAgICBpZiAoIWlzTWF0Y2hpbmdSb3cgJiYgcm93LmNvbGxhcHNlZCkgYWNjLmNvbGxhcHNlZFJvd0lEcy5wdXNoKHJvdy5pZClcbiAgICAgICAgICBlbHNlIGlmIChpc01hdGNoaW5nUm93ICYmIGNvbGxhcHNlZCkgYWNjLmNvbGxhcHNlZFJvd0lEcy5wdXNoKHJvdy5pZClcblxuICAgICAgICAgIHJldHVybiBhY2NcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGNvbGxhcHNlZFJvd0lEczogW10sXG4gICAgICAgICAgbWF0Y2hlZEluZGV4OiB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgICApXG5cbiAgICAgIGlmIChtYXRjaGVkSW5kZXggPiAtMSkge1xuICAgICAgICBhcnJheVN0YXRlLnJvd3NbbWF0Y2hlZEluZGV4XS5jb2xsYXBzZWQgPSBjb2xsYXBzZWRcbiAgICAgICAgc2V0RG9jRmllbGRQcmVmZXJlbmNlcyhwYXRoLCB7IGNvbGxhcHNlZDogY29sbGFwc2VkUm93SURzIH0pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgW3BhdGhdOiB7XG4gICAgICAgICAgLi4uYXJyYXlTdGF0ZSxcbiAgICAgICAgfSxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1N0YXRlXG4gICAgfVxuXG4gICAgY2FzZSAnU0VUX0FMTF9ST1dTX0NPTExBUFNFRCc6IHtcbiAgICAgIGNvbnN0IHsgY29sbGFwc2VkLCBwYXRoLCBzZXREb2NGaWVsZFByZWZlcmVuY2VzIH0gPSBhY3Rpb25cblxuICAgICAgY29uc3QgeyBjb2xsYXBzZWRSb3dJRHMsIHJvd3MgfSA9IHN0YXRlW3BhdGhdLnJvd3MucmVkdWNlKFxuICAgICAgICAoYWNjLCByb3cpID0+IHtcbiAgICAgICAgICBpZiAoY29sbGFwc2VkKSBhY2MuY29sbGFwc2VkUm93SURzLnB1c2gocm93LmlkKVxuXG4gICAgICAgICAgYWNjLnJvd3MucHVzaCh7XG4gICAgICAgICAgICAuLi5yb3csXG4gICAgICAgICAgICBjb2xsYXBzZWQsXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJldHVybiBhY2NcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGNvbGxhcHNlZFJvd0lEczogW10sXG4gICAgICAgICAgcm93czogW10sXG4gICAgICAgIH0sXG4gICAgICApXG5cbiAgICAgIHNldERvY0ZpZWxkUHJlZmVyZW5jZXMocGF0aCwgeyBjb2xsYXBzZWQ6IGNvbGxhcHNlZFJvd0lEcyB9KVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgW3BhdGhdOiB7XG4gICAgICAgICAgLi4uc3RhdGVbcGF0aF0sXG4gICAgICAgICAgcm93cyxcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gc3RhdGVcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJmaWVsZFJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsInR5cGUiLCJuZXdTdGF0ZSIsIk9iamVjdCIsImVudHJpZXMiLCJmb3JFYWNoIiwicGF0aCIsImZpZWxkIiwib2xkRmllbGQiLCJuZXdGaWVsZCIsImVxdWFsIiwicmVzdWx0IiwidXNlciIsInJlZHVjZSIsImZpZWxkUGF0aCIsImluZGV4T2YiLCJwYXNzZXNDb25kaXRpb24iLCJjb25kaXRpb24iLCJCb29sZWFuIiwicmVkdWNlRmllbGRzVG9WYWx1ZXMiLCJnZXRTaWJsaW5nRGF0YSIsImtleSIsInZhbHVlIiwiaW5jbHVkZXMiLCJyb3dJbmRleCIsInJlbWFpbmluZ0ZpZWxkcyIsInJvd3MiLCJzZXBhcmF0ZVJvd3MiLCJyb3dzTWV0YWRhdGEiLCJzcGxpY2UiLCJkaXNhYmxlRm9ybURhdGEiLCJsZW5ndGgiLCJmbGF0dGVuUm93cyIsImJsb2NrVHlwZSIsInJvd0luZGV4RnJvbUFyZ3MiLCJzdWJGaWVsZFN0YXRlIiwiaWQiLCJPYmplY3RJRCIsInRvSGV4U3RyaW5nIiwidW5kZWZpbmVkIiwiY2hpbGRFcnJvclBhdGhzIiwiU2V0IiwiY29sbGFwc2VkIiwiaW5pdGlhbFZhbHVlIiwidmFsaWQiLCJzaWJsaW5nUm93cyIsInJvd0luZGV4QXJnIiwiTWF0aCIsIm1heCIsIm1pbiIsImR1cGxpY2F0ZVJvd01ldGFkYXRhIiwiZGVlcENvcHlPYmplY3QiLCJkdXBsaWNhdGVSb3dTdGF0ZSIsImtleXMiLCJtb3ZlRnJvbUluZGV4IiwibW92ZVRvSW5kZXgiLCJjb3B5T2ZNb3ZpbmdSb3ciLCJyb3dTdGF0ZUNvcHkiLCJtb3ZpbmdSb3dTdGF0ZSIsInJvd0lEIiwic2V0RG9jRmllbGRQcmVmZXJlbmNlcyIsImFycmF5U3RhdGUiLCJjb2xsYXBzZWRSb3dJRHMiLCJtYXRjaGVkSW5kZXgiLCJhY2MiLCJyb3ciLCJpbmRleCIsImlzTWF0Y2hpbmdSb3ciLCJwdXNoIl0sIm1hcHBpbmdzIjoiOzs7OytCQWFnQkE7OztlQUFBQTs7O3FFQWJLO2tFQUNIO2dDQUlhO3VFQUNKOzZFQUNNO3NCQUNTOzs7Ozs7QUFLbkMsU0FBU0EsYUFBYUMsS0FBYSxFQUFFQyxNQUFtQjtJQUM3RCxPQUFRQSxPQUFPQyxJQUFJO1FBQ2pCLEtBQUs7WUFBaUI7Z0JBQ3BCLE1BQU1DLFdBQVcsQ0FBQztnQkFFbEIsdUNBQXVDO2dCQUN2QywrQ0FBK0M7Z0JBQy9DLEtBQUs7Z0JBQ0wsK0NBQStDO2dCQUMvQywwQ0FBMEM7Z0JBRTFDQyxPQUFPQyxPQUFPLENBQUNKLE9BQU9ELEtBQUssRUFBRU0sT0FBTyxDQUFDLENBQUMsQ0FBQ0MsTUFBTUMsTUFBTTtvQkFDakQsTUFBTUMsV0FBV1QsS0FBSyxDQUFDTyxLQUFLO29CQUM1QixNQUFNRyxXQUFXRjtvQkFFakIsSUFBSSxDQUFDRyxJQUFBQSxrQkFBSyxFQUFDRixVQUFVQyxXQUFXO3dCQUM5QlAsUUFBUSxDQUFDSSxLQUFLLEdBQUdHO29CQUNuQixPQUFPLElBQUlELFVBQVU7d0JBQ25CTixRQUFRLENBQUNJLEtBQUssR0FBR0U7b0JBQ25CO2dCQUNGO2dCQUVBLE9BQU9OO1lBQ1Q7UUFFQSxLQUFLO1lBQVU7Z0JBQ2IsTUFBTUEsV0FBVztvQkFBRSxHQUFHSCxLQUFLO2dCQUFDO2dCQUM1QixJQUFJRyxRQUFRLENBQUNGLE9BQU9NLElBQUksQ0FBQyxFQUFFLE9BQU9KLFFBQVEsQ0FBQ0YsT0FBT00sSUFBSSxDQUFDO2dCQUN2RCxPQUFPSjtZQUNUO1FBRUEsS0FBSztZQUFvQjtnQkFDdkIsTUFBTSxFQUFFSSxJQUFJLEVBQUVLLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEdBQUdaO2dCQUUvQixPQUFPRyxPQUFPQyxPQUFPLENBQUNMLE9BQU9jLE1BQU0sQ0FBQyxDQUFDWCxVQUFVLENBQUNZLFdBQVdQLE1BQU07b0JBQy9ELElBQUlPLGNBQWNSLFFBQVFRLFVBQVVDLE9BQU8sQ0FBQyxDQUFDLEVBQUVULEtBQUssQ0FBQyxDQUFDLE1BQU0sR0FBRzt3QkFDN0QsSUFBSVUsa0JBQWtCTDt3QkFFdEIsdUNBQXVDO3dCQUN2Qyw2QkFBNkI7d0JBQzdCLG9EQUFvRDt3QkFFcEQsSUFBSUssbUJBQW1CVCxNQUFNVSxTQUFTLEVBQUU7NEJBQ3RDRCxrQkFBa0JFLFFBQ2hCWCxNQUFNVSxTQUFTLENBQUNFLElBQUFBLDZCQUFvQixFQUFDcEIsT0FBTyxPQUFPcUIsSUFBQUEsdUJBQWMsRUFBQ3JCLE9BQU9PLE9BQU87Z0NBQzlFTTs0QkFDRjt3QkFFSjt3QkFFQSxPQUFPOzRCQUNMLEdBQUdWLFFBQVE7NEJBQ1gsQ0FBQ1ksVUFBVSxFQUFFO2dDQUNYLEdBQUdQLEtBQUs7Z0NBQ1JTOzRCQUNGO3dCQUNGO29CQUNGO29CQUVBLE9BQU87d0JBQ0wsR0FBR2QsUUFBUTt3QkFDWCxDQUFDWSxVQUFVLEVBQUU7NEJBQ1gsR0FBR1AsS0FBSzt3QkFDVjtvQkFDRjtnQkFDRixHQUFHLENBQUM7WUFDTjtRQUVBLEtBQUs7WUFBVTtnQkFDYixNQUFNRSxXQUFXTixPQUFPQyxPQUFPLENBQUNKLFFBQVFhLE1BQU0sQ0FDNUMsQ0FBQ04sT0FBTyxDQUFDYyxLQUFLQyxNQUFNO29CQUNsQixJQUNFO3dCQUNFO3dCQUNBO3dCQUNBO3dCQUNBO3dCQUNBO3dCQUNBO3dCQUNBO3dCQUNBO3dCQUNBO3FCQUNELENBQUNDLFFBQVEsQ0FBQ0YsTUFDWDt3QkFDQSxPQUFPOzRCQUNMLEdBQUdkLEtBQUs7NEJBQ1IsQ0FBQ2MsSUFBSSxFQUFFQzt3QkFDVDtvQkFDRjtvQkFFQSxPQUFPZjtnQkFDVCxHQUNBUixLQUFLLENBQUNDLE9BQU9NLElBQUksQ0FBQyxJQUFLLENBQUM7Z0JBRzFCLE9BQU87b0JBQ0wsR0FBR1AsS0FBSztvQkFDUixDQUFDQyxPQUFPTSxJQUFJLENBQUMsRUFBRUc7Z0JBQ2pCO1lBQ0Y7UUFFQSxLQUFLO1lBQWM7Z0JBQ2pCLE1BQU0sRUFBRUgsSUFBSSxFQUFFa0IsUUFBUSxFQUFFLEdBQUd4QjtnQkFDM0IsTUFBTSxFQUFFeUIsZUFBZSxFQUFFQyxJQUFJLEVBQUUsR0FBR0MsSUFBQUEsa0JBQVksRUFBQ3JCLE1BQU1QO2dCQUNyRCxNQUFNNkIsZUFBZTt1QkFBSzdCLEtBQUssQ0FBQ08sS0FBSyxFQUFFb0IsUUFBUSxFQUFFO2lCQUFFO2dCQUVuREEsS0FBS0csTUFBTSxDQUFDTCxVQUFVO2dCQUN0QkksYUFBYUMsTUFBTSxDQUFDTCxVQUFVO2dCQUU5QixNQUFNdEIsV0FBbUI7b0JBQ3ZCLEdBQUd1QixlQUFlO29CQUNsQixDQUFDbkIsS0FBSyxFQUFFO3dCQUNOLEdBQUdQLEtBQUssQ0FBQ08sS0FBSzt3QkFDZHdCLGlCQUFpQkosS0FBS0ssTUFBTSxHQUFHO3dCQUMvQkwsTUFBTUU7d0JBQ05OLE9BQU9JLEtBQUtLLE1BQU07b0JBQ3BCO29CQUNBLEdBQUdDLElBQUFBLGlCQUFXLEVBQUMxQixNQUFNb0IsS0FBSztnQkFDNUI7Z0JBRUEsT0FBT3hCO1lBQ1Q7UUFFQSxLQUFLO1lBQVc7Z0JBQ2QsTUFBTSxFQUFFK0IsU0FBUyxFQUFFM0IsSUFBSSxFQUFFa0IsVUFBVVUsZ0JBQWdCLEVBQUVDLGFBQWEsRUFBRSxHQUFHbkM7Z0JBQ3ZFLE1BQU13QixXQUNKLE9BQU9VLHFCQUFxQixXQUFXQSxtQkFBbUJuQyxLQUFLLENBQUNPLEtBQUssRUFBRW9CLE1BQU1LLFVBQVU7Z0JBRXpGLE1BQU1ILGVBQWU7dUJBQUs3QixLQUFLLENBQUNPLEtBQUssRUFBRW9CLFFBQVEsRUFBRTtpQkFBRTtnQkFDbkRFLGFBQWFDLE1BQU0sQ0FDakJMLFVBQ0EsR0FDQSxVQUFVO2dCQUNWO29CQUNFWSxJQUFJLElBQUlDLHFCQUFRLEdBQUdDLFdBQVc7b0JBQzlCTCxXQUFXQSxhQUFhTTtvQkFDeEJDLGlCQUFpQixJQUFJQztvQkFDckJDLFdBQVc7Z0JBQ2I7Z0JBR0YsSUFBSVQsV0FBVztvQkFDYkUsY0FBY0YsU0FBUyxHQUFHO3dCQUN4QlUsY0FBY1Y7d0JBQ2RXLE9BQU87d0JBQ1B0QixPQUFPVztvQkFDVDtnQkFDRjtnQkFFQSxxQ0FBcUM7Z0JBQ3JDLE1BQU0sRUFBRVIsZUFBZSxFQUFFQyxNQUFNbUIsV0FBVyxFQUFFLEdBQUdsQixJQUFBQSxrQkFBWSxFQUFDckIsTUFBTVA7Z0JBQ2xFOEMsWUFBWWhCLE1BQU0sQ0FBQ0wsVUFBVSxHQUFHVztnQkFFaEMsTUFBTWpDLFdBQW1CO29CQUN2QixHQUFHdUIsZUFBZTtvQkFDbEIsR0FBR08sSUFBQUEsaUJBQVcsRUFBQzFCLE1BQU11QyxZQUFZO29CQUNqQyxDQUFDdkMsS0FBSyxFQUFFO3dCQUNOLEdBQUdQLEtBQUssQ0FBQ08sS0FBSzt3QkFDZHdCLGlCQUFpQjt3QkFDakJKLE1BQU1FO3dCQUNOTixPQUFPdUIsWUFBWWQsTUFBTTtvQkFDM0I7Z0JBQ0Y7Z0JBRUEsT0FBTzdCO1lBQ1Q7UUFFQSxLQUFLO1lBQWU7Z0JBQ2xCLE1BQU0sRUFBRStCLFNBQVMsRUFBRTNCLElBQUksRUFBRWtCLFVBQVVzQixXQUFXLEVBQUVYLGFBQWEsRUFBRSxHQUFHbkM7Z0JBQ2xFLE1BQU0sRUFBRXlCLGVBQWUsRUFBRUMsTUFBTW1CLFdBQVcsRUFBRSxHQUFHbEIsSUFBQUEsa0JBQVksRUFBQ3JCLE1BQU1QO2dCQUNsRSxNQUFNeUIsV0FBV3VCLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUNILGFBQWFELGFBQWFkLFNBQVMsS0FBSztnQkFFOUUsTUFBTUgsZUFBZTt1QkFBSzdCLEtBQUssQ0FBQ08sS0FBSyxFQUFFb0IsUUFBUSxFQUFFO2lCQUFFO2dCQUNuREUsWUFBWSxDQUFDSixTQUFTLEdBQUc7b0JBQ3ZCWSxJQUFJLElBQUlDLHFCQUFRLEdBQUdDLFdBQVc7b0JBQzlCTCxXQUFXQSxhQUFhTTtvQkFDeEJDLGlCQUFpQixJQUFJQztvQkFDckJDLFdBQVc7Z0JBQ2I7Z0JBRUEsSUFBSVQsV0FBVztvQkFDYkUsY0FBY0YsU0FBUyxHQUFHO3dCQUN4QlUsY0FBY1Y7d0JBQ2RXLE9BQU87d0JBQ1B0QixPQUFPVztvQkFDVDtnQkFDRjtnQkFFQSw2QkFBNkI7Z0JBQzdCWSxXQUFXLENBQUNyQixTQUFTLEdBQUdXO2dCQUV4QixNQUFNakMsV0FBbUI7b0JBQ3ZCLEdBQUd1QixlQUFlO29CQUNsQixHQUFHTyxJQUFBQSxpQkFBVyxFQUFDMUIsTUFBTXVDLFlBQVk7b0JBQ2pDLENBQUN2QyxLQUFLLEVBQUU7d0JBQ04sR0FBR1AsS0FBSyxDQUFDTyxLQUFLO3dCQUNkd0IsaUJBQWlCO3dCQUNqQkosTUFBTUU7d0JBQ05OLE9BQU91QixZQUFZZCxNQUFNO29CQUMzQjtnQkFDRjtnQkFFQSxPQUFPN0I7WUFDVDtRQUVBLEtBQUs7WUFBaUI7Z0JBQ3BCLE1BQU0sRUFBRUksSUFBSSxFQUFFa0IsUUFBUSxFQUFFLEdBQUd4QjtnQkFDM0IsTUFBTSxFQUFFeUIsZUFBZSxFQUFFQyxJQUFJLEVBQUUsR0FBR0MsSUFBQUEsa0JBQVksRUFBQ3JCLE1BQU1QO2dCQUNyRCxNQUFNNkIsZUFBZTdCLEtBQUssQ0FBQ08sS0FBSyxFQUFFb0IsUUFBUSxFQUFFO2dCQUU1QyxNQUFNd0IsdUJBQXVCQyxJQUFBQSw4QkFBYyxFQUFDdkIsWUFBWSxDQUFDSixTQUFTO2dCQUNsRSxJQUFJMEIscUJBQXFCZCxFQUFFLEVBQUVjLHFCQUFxQmQsRUFBRSxHQUFHLElBQUlDLHFCQUFRLEdBQUdDLFdBQVc7Z0JBRWpGLE1BQU1jLG9CQUFvQkQsSUFBQUEsOEJBQWMsRUFBQ3pCLElBQUksQ0FBQ0YsU0FBUztnQkFDdkQsSUFBSTRCLGtCQUFrQmhCLEVBQUUsRUFBRWdCLGtCQUFrQmhCLEVBQUUsR0FBRyxJQUFJQyxxQkFBUSxHQUFHQyxXQUFXO2dCQUUzRSx5QkFBeUI7Z0JBQ3pCLElBQUluQyxPQUFPa0QsSUFBSSxDQUFDRCxtQkFBbUJyQixNQUFNLEdBQUcsR0FBRztvQkFDN0Msb0VBQW9FO29CQUNwRUwsS0FBS0csTUFBTSxDQUFDTCxXQUFXLEdBQUcsR0FBRzRCO29CQUM3QnhCLGFBQWFDLE1BQU0sQ0FBQ0wsV0FBVyxHQUFHLEdBQUcwQjtnQkFDdkM7Z0JBRUEsTUFBTWhELFdBQVc7b0JBQ2YsR0FBR3VCLGVBQWU7b0JBQ2xCLENBQUNuQixLQUFLLEVBQUU7d0JBQ04sR0FBR1AsS0FBSyxDQUFDTyxLQUFLO3dCQUNkd0IsaUJBQWlCO3dCQUNqQkosTUFBTUU7d0JBQ05OLE9BQU9JLEtBQUtLLE1BQU07b0JBQ3BCO29CQUNBLEdBQUdDLElBQUFBLGlCQUFXLEVBQUMxQixNQUFNb0IsS0FBSztnQkFDNUI7Z0JBRUEsT0FBT3hCO1lBQ1Q7UUFFQSxLQUFLO1lBQVk7Z0JBQ2YsTUFBTSxFQUFFb0QsYUFBYSxFQUFFQyxXQUFXLEVBQUVqRCxJQUFJLEVBQUUsR0FBR047Z0JBQzdDLE1BQU0sRUFBRXlCLGVBQWUsRUFBRUMsSUFBSSxFQUFFLEdBQUdDLElBQUFBLGtCQUFZLEVBQUNyQixNQUFNUDtnQkFFckQsdUJBQXVCO2dCQUN2QixNQUFNeUQsa0JBQWtCOUIsSUFBSSxDQUFDNEIsY0FBYztnQkFDM0MsMEJBQTBCO2dCQUMxQjVCLEtBQUtHLE1BQU0sQ0FBQ3lCLGVBQWU7Z0JBQzNCLHFDQUFxQztnQkFDckM1QixLQUFLRyxNQUFNLENBQUMwQixhQUFhLEdBQUdDO2dCQUU1QixvRUFBb0U7Z0JBQ3BFLE1BQU1DLGVBQWU7dUJBQUsxRCxLQUFLLENBQUNPLEtBQUssRUFBRW9CLFFBQVEsRUFBRTtpQkFBRTtnQkFDbkQsTUFBTWdDLGlCQUFpQjtvQkFBRSxHQUFHRCxZQUFZLENBQUNILGNBQWM7Z0JBQUM7Z0JBQ3hERyxhQUFhNUIsTUFBTSxDQUFDeUIsZUFBZTtnQkFDbkNHLGFBQWE1QixNQUFNLENBQUMwQixhQUFhLEdBQUdHO2dCQUVwQyxNQUFNeEQsV0FBVztvQkFDZixHQUFHdUIsZUFBZTtvQkFDbEIsR0FBR08sSUFBQUEsaUJBQVcsRUFBQzFCLE1BQU1vQixLQUFLO29CQUMxQixDQUFDcEIsS0FBSyxFQUFFO3dCQUNOLEdBQUdQLEtBQUssQ0FBQ08sS0FBSzt3QkFDZG9CLE1BQU0rQjtvQkFDUjtnQkFDRjtnQkFFQSxPQUFPdkQ7WUFDVDtRQUVBLEtBQUs7WUFBcUI7Z0JBQ3hCLE1BQU0sRUFBRXdDLFNBQVMsRUFBRXBDLElBQUksRUFBRXFELEtBQUssRUFBRUMsc0JBQXNCLEVBQUUsR0FBRzVEO2dCQUUzRCxNQUFNNkQsYUFBYTlELEtBQUssQ0FBQ08sS0FBSztnQkFFOUIsTUFBTSxFQUFFd0QsZUFBZSxFQUFFQyxZQUFZLEVBQUUsR0FBR2hFLEtBQUssQ0FBQ08sS0FBSyxDQUFDb0IsSUFBSSxDQUFDYixNQUFNLENBQy9ELENBQUNtRCxLQUFLQyxLQUFLQztvQkFDVCxNQUFNQyxnQkFBZ0JGLElBQUk3QixFQUFFLEtBQUt1QjtvQkFDakMsSUFBSVEsZUFBZUgsSUFBSUQsWUFBWSxHQUFHRztvQkFFdEMsSUFBSSxDQUFDQyxpQkFBaUJGLElBQUl2QixTQUFTLEVBQUVzQixJQUFJRixlQUFlLENBQUNNLElBQUksQ0FBQ0gsSUFBSTdCLEVBQUU7eUJBQy9ELElBQUkrQixpQkFBaUJ6QixXQUFXc0IsSUFBSUYsZUFBZSxDQUFDTSxJQUFJLENBQUNILElBQUk3QixFQUFFO29CQUVwRSxPQUFPNEI7Z0JBQ1QsR0FDQTtvQkFDRUYsaUJBQWlCLEVBQUU7b0JBQ25CQyxjQUFjeEI7Z0JBQ2hCO2dCQUdGLElBQUl3QixlQUFlLENBQUMsR0FBRztvQkFDckJGLFdBQVduQyxJQUFJLENBQUNxQyxhQUFhLENBQUNyQixTQUFTLEdBQUdBO29CQUMxQ2tCLHVCQUF1QnRELE1BQU07d0JBQUVvQyxXQUFXb0I7b0JBQWdCO2dCQUM1RDtnQkFFQSxNQUFNNUQsV0FBVztvQkFDZixHQUFHSCxLQUFLO29CQUNSLENBQUNPLEtBQUssRUFBRTt3QkFDTixHQUFHdUQsVUFBVTtvQkFDZjtnQkFDRjtnQkFFQSxPQUFPM0Q7WUFDVDtRQUVBLEtBQUs7WUFBMEI7Z0JBQzdCLE1BQU0sRUFBRXdDLFNBQVMsRUFBRXBDLElBQUksRUFBRXNELHNCQUFzQixFQUFFLEdBQUc1RDtnQkFFcEQsTUFBTSxFQUFFOEQsZUFBZSxFQUFFcEMsSUFBSSxFQUFFLEdBQUczQixLQUFLLENBQUNPLEtBQUssQ0FBQ29CLElBQUksQ0FBQ2IsTUFBTSxDQUN2RCxDQUFDbUQsS0FBS0M7b0JBQ0osSUFBSXZCLFdBQVdzQixJQUFJRixlQUFlLENBQUNNLElBQUksQ0FBQ0gsSUFBSTdCLEVBQUU7b0JBRTlDNEIsSUFBSXRDLElBQUksQ0FBQzBDLElBQUksQ0FBQzt3QkFDWixHQUFHSCxHQUFHO3dCQUNOdkI7b0JBQ0Y7b0JBRUEsT0FBT3NCO2dCQUNULEdBQ0E7b0JBQ0VGLGlCQUFpQixFQUFFO29CQUNuQnBDLE1BQU0sRUFBRTtnQkFDVjtnQkFHRmtDLHVCQUF1QnRELE1BQU07b0JBQUVvQyxXQUFXb0I7Z0JBQWdCO2dCQUUxRCxPQUFPO29CQUNMLEdBQUcvRCxLQUFLO29CQUNSLENBQUNPLEtBQUssRUFBRTt3QkFDTixHQUFHUCxLQUFLLENBQUNPLEtBQUs7d0JBQ2RvQjtvQkFDRjtnQkFDRjtZQUNGO1FBRUE7WUFBUztnQkFDUCxPQUFPM0I7WUFDVDtJQUNGO0FBQ0YifQ==