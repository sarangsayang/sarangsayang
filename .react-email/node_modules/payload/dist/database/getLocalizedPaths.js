"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getLocalizedPaths", {
    enumerable: true,
    get: function() {
        return getLocalizedPaths;
    }
});
const _types = require("../fields/config/types");
const _flattenTopLevelFields = /*#__PURE__*/ _interop_require_default(require("../utilities/flattenTopLevelFields"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
async function getLocalizedPaths({ collectionSlug, fields, globalSlug, incomingPath, locale, overrideAccess = false, payload }) {
    const pathSegments = incomingPath.split('.');
    const localizationConfig = payload.config.localization;
    let paths = [
        {
            collectionSlug,
            complete: false,
            field: undefined,
            fields: (0, _flattenTopLevelFields.default)(fields, false),
            globalSlug,
            invalid: false,
            path: ''
        }
    ];
    for(let i = 0; i < pathSegments.length; i += 1){
        const segment = pathSegments[i];
        const lastIncompletePath = paths.find(({ complete })=>!complete);
        if (lastIncompletePath) {
            const { path } = lastIncompletePath;
            let currentPath = path ? `${path}.${segment}` : segment;
            const matchedField = lastIncompletePath.fields.find((field)=>(0, _types.fieldAffectsData)(field) && field.name === segment);
            lastIncompletePath.field = matchedField;
            if (currentPath === 'globalType' && globalSlug) {
                lastIncompletePath.path = currentPath;
                lastIncompletePath.complete = true;
                lastIncompletePath.field = {
                    name: 'globalType',
                    type: 'text'
                };
                return paths;
            }
            if (matchedField) {
                if ('hidden' in matchedField && matchedField.hidden && !overrideAccess) {
                    lastIncompletePath.invalid = true;
                }
                const nextSegment = pathSegments[i + 1];
                const nextSegmentIsLocale = localizationConfig && localizationConfig.localeCodes.includes(nextSegment);
                if (nextSegmentIsLocale) {
                    // Skip the next iteration, because it's a locale
                    i += 1;
                    currentPath = `${currentPath}.${nextSegment}`;
                } else if (localizationConfig && 'localized' in matchedField && matchedField.localized) {
                    currentPath = `${currentPath}.${locale}`;
                }
                switch(matchedField.type){
                    case 'blocks':
                    case 'richText':
                    case 'json':
                        {
                            const upcomingSegments = pathSegments.slice(i + 1).join('.');
                            lastIncompletePath.complete = true;
                            lastIncompletePath.path = upcomingSegments ? `${currentPath}.${upcomingSegments}` : currentPath;
                            return paths;
                        }
                    case 'relationship':
                    case 'upload':
                        {
                            // If this is a polymorphic relation,
                            // We only support querying directly (no nested querying)
                            if (typeof matchedField.relationTo !== 'string') {
                                const lastSegmentIsValid = [
                                    'relationTo',
                                    'value'
                                ].includes(pathSegments[pathSegments.length - 1]) || pathSegments.length === 1;
                                if (lastSegmentIsValid) {
                                    lastIncompletePath.complete = true;
                                    lastIncompletePath.path = pathSegments.join('.');
                                } else {
                                    lastIncompletePath.invalid = true;
                                    return paths;
                                }
                            } else {
                                lastIncompletePath.complete = true;
                                lastIncompletePath.path = currentPath;
                                const nestedPathToQuery = pathSegments.slice(nextSegmentIsLocale ? i + 2 : i + 1).join('.');
                                if (nestedPathToQuery) {
                                    const relatedCollection = payload.collections[matchedField.relationTo].config;
                                    // eslint-disable-next-line no-await-in-loop
                                    const remainingPaths = await getLocalizedPaths({
                                        collectionSlug: relatedCollection.slug,
                                        fields: relatedCollection.fields,
                                        globalSlug,
                                        incomingPath: nestedPathToQuery,
                                        locale,
                                        payload
                                    });
                                    paths = [
                                        ...paths,
                                        ...remainingPaths
                                    ];
                                }
                                return paths;
                            }
                            break;
                        }
                    default:
                        {
                            if ('fields' in lastIncompletePath.field) {
                                lastIncompletePath.fields = (0, _flattenTopLevelFields.default)(lastIncompletePath.field.fields, false);
                            }
                            if (i + 1 === pathSegments.length) lastIncompletePath.complete = true;
                            lastIncompletePath.path = currentPath;
                        }
                }
            } else {
                lastIncompletePath.invalid = true;
                lastIncompletePath.path = currentPath;
                return paths;
            }
        }
    }
    return paths;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kYXRhYmFzZS9nZXRMb2NhbGl6ZWRQYXRocy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFBheWxvYWQgfSBmcm9tICcuLidcbmltcG9ydCB0eXBlIHsgRmllbGQgfSBmcm9tICcuLi9maWVsZHMvY29uZmlnL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBQYXRoVG9RdWVyeSB9IGZyb20gJy4vcXVlcnlWYWxpZGF0aW9uL3R5cGVzJ1xuXG5pbXBvcnQgeyBmaWVsZEFmZmVjdHNEYXRhIH0gZnJvbSAnLi4vZmllbGRzL2NvbmZpZy90eXBlcydcbmltcG9ydCBmbGF0dGVuRmllbGRzIGZyb20gJy4uL3V0aWxpdGllcy9mbGF0dGVuVG9wTGV2ZWxGaWVsZHMnXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRMb2NhbGl6ZWRQYXRocyh7XG4gIGNvbGxlY3Rpb25TbHVnLFxuICBmaWVsZHMsXG4gIGdsb2JhbFNsdWcsXG4gIGluY29taW5nUGF0aCxcbiAgbG9jYWxlLFxuICBvdmVycmlkZUFjY2VzcyA9IGZhbHNlLFxuICBwYXlsb2FkLFxufToge1xuICBjb2xsZWN0aW9uU2x1Zz86IHN0cmluZ1xuICBmaWVsZHM6IEZpZWxkW11cbiAgZ2xvYmFsU2x1Zz86IHN0cmluZ1xuICBpbmNvbWluZ1BhdGg6IHN0cmluZ1xuICBsb2NhbGU/OiBzdHJpbmdcbiAgb3ZlcnJpZGVBY2Nlc3M/OiBib29sZWFuXG4gIHBheWxvYWQ6IFBheWxvYWRcbn0pOiBQcm9taXNlPFBhdGhUb1F1ZXJ5W10+IHtcbiAgY29uc3QgcGF0aFNlZ21lbnRzID0gaW5jb21pbmdQYXRoLnNwbGl0KCcuJylcbiAgY29uc3QgbG9jYWxpemF0aW9uQ29uZmlnID0gcGF5bG9hZC5jb25maWcubG9jYWxpemF0aW9uXG5cbiAgbGV0IHBhdGhzOiBQYXRoVG9RdWVyeVtdID0gW1xuICAgIHtcbiAgICAgIGNvbGxlY3Rpb25TbHVnLFxuICAgICAgY29tcGxldGU6IGZhbHNlLFxuICAgICAgZmllbGQ6IHVuZGVmaW5lZCxcbiAgICAgIGZpZWxkczogZmxhdHRlbkZpZWxkcyhmaWVsZHMsIGZhbHNlKSxcbiAgICAgIGdsb2JhbFNsdWcsXG4gICAgICBpbnZhbGlkOiBmYWxzZSxcbiAgICAgIHBhdGg6ICcnLFxuICAgIH0sXG4gIF1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhTZWdtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBwYXRoU2VnbWVudHNbaV1cblxuICAgIGNvbnN0IGxhc3RJbmNvbXBsZXRlUGF0aCA9IHBhdGhzLmZpbmQoKHsgY29tcGxldGUgfSkgPT4gIWNvbXBsZXRlKVxuXG4gICAgaWYgKGxhc3RJbmNvbXBsZXRlUGF0aCkge1xuICAgICAgY29uc3QgeyBwYXRoIH0gPSBsYXN0SW5jb21wbGV0ZVBhdGhcbiAgICAgIGxldCBjdXJyZW50UGF0aCA9IHBhdGggPyBgJHtwYXRofS4ke3NlZ21lbnR9YCA6IHNlZ21lbnRcblxuICAgICAgY29uc3QgbWF0Y2hlZEZpZWxkID0gbGFzdEluY29tcGxldGVQYXRoLmZpZWxkcy5maW5kKFxuICAgICAgICAoZmllbGQpID0+IGZpZWxkQWZmZWN0c0RhdGEoZmllbGQpICYmIGZpZWxkLm5hbWUgPT09IHNlZ21lbnQsXG4gICAgICApXG4gICAgICBsYXN0SW5jb21wbGV0ZVBhdGguZmllbGQgPSBtYXRjaGVkRmllbGRcblxuICAgICAgaWYgKGN1cnJlbnRQYXRoID09PSAnZ2xvYmFsVHlwZScgJiYgZ2xvYmFsU2x1Zykge1xuICAgICAgICBsYXN0SW5jb21wbGV0ZVBhdGgucGF0aCA9IGN1cnJlbnRQYXRoXG4gICAgICAgIGxhc3RJbmNvbXBsZXRlUGF0aC5jb21wbGV0ZSA9IHRydWVcbiAgICAgICAgbGFzdEluY29tcGxldGVQYXRoLmZpZWxkID0ge1xuICAgICAgICAgIG5hbWU6ICdnbG9iYWxUeXBlJyxcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aHNcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoZWRGaWVsZCkge1xuICAgICAgICBpZiAoJ2hpZGRlbicgaW4gbWF0Y2hlZEZpZWxkICYmIG1hdGNoZWRGaWVsZC5oaWRkZW4gJiYgIW92ZXJyaWRlQWNjZXNzKSB7XG4gICAgICAgICAgbGFzdEluY29tcGxldGVQYXRoLmludmFsaWQgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXh0U2VnbWVudCA9IHBhdGhTZWdtZW50c1tpICsgMV1cbiAgICAgICAgY29uc3QgbmV4dFNlZ21lbnRJc0xvY2FsZSA9XG4gICAgICAgICAgbG9jYWxpemF0aW9uQ29uZmlnICYmIGxvY2FsaXphdGlvbkNvbmZpZy5sb2NhbGVDb2Rlcy5pbmNsdWRlcyhuZXh0U2VnbWVudClcblxuICAgICAgICBpZiAobmV4dFNlZ21lbnRJc0xvY2FsZSkge1xuICAgICAgICAgIC8vIFNraXAgdGhlIG5leHQgaXRlcmF0aW9uLCBiZWNhdXNlIGl0J3MgYSBsb2NhbGVcbiAgICAgICAgICBpICs9IDFcbiAgICAgICAgICBjdXJyZW50UGF0aCA9IGAke2N1cnJlbnRQYXRofS4ke25leHRTZWdtZW50fWBcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGl6YXRpb25Db25maWcgJiYgJ2xvY2FsaXplZCcgaW4gbWF0Y2hlZEZpZWxkICYmIG1hdGNoZWRGaWVsZC5sb2NhbGl6ZWQpIHtcbiAgICAgICAgICBjdXJyZW50UGF0aCA9IGAke2N1cnJlbnRQYXRofS4ke2xvY2FsZX1gXG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKG1hdGNoZWRGaWVsZC50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnYmxvY2tzJzpcbiAgICAgICAgICBjYXNlICdyaWNoVGV4dCc6XG4gICAgICAgICAgY2FzZSAnanNvbic6IHtcbiAgICAgICAgICAgIGNvbnN0IHVwY29taW5nU2VnbWVudHMgPSBwYXRoU2VnbWVudHMuc2xpY2UoaSArIDEpLmpvaW4oJy4nKVxuICAgICAgICAgICAgbGFzdEluY29tcGxldGVQYXRoLmNvbXBsZXRlID0gdHJ1ZVxuICAgICAgICAgICAgbGFzdEluY29tcGxldGVQYXRoLnBhdGggPSB1cGNvbWluZ1NlZ21lbnRzXG4gICAgICAgICAgICAgID8gYCR7Y3VycmVudFBhdGh9LiR7dXBjb21pbmdTZWdtZW50c31gXG4gICAgICAgICAgICAgIDogY3VycmVudFBhdGhcbiAgICAgICAgICAgIHJldHVybiBwYXRoc1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3JlbGF0aW9uc2hpcCc6XG4gICAgICAgICAgY2FzZSAndXBsb2FkJzoge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHBvbHltb3JwaGljIHJlbGF0aW9uLFxuICAgICAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHF1ZXJ5aW5nIGRpcmVjdGx5IChubyBuZXN0ZWQgcXVlcnlpbmcpXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1hdGNoZWRGaWVsZC5yZWxhdGlvblRvICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb25zdCBsYXN0U2VnbWVudElzVmFsaWQgPVxuICAgICAgICAgICAgICAgIFsncmVsYXRpb25UbycsICd2YWx1ZSddLmluY2x1ZGVzKHBhdGhTZWdtZW50c1twYXRoU2VnbWVudHMubGVuZ3RoIC0gMV0pIHx8XG4gICAgICAgICAgICAgICAgcGF0aFNlZ21lbnRzLmxlbmd0aCA9PT0gMVxuXG4gICAgICAgICAgICAgIGlmIChsYXN0U2VnbWVudElzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBsYXN0SW5jb21wbGV0ZVBhdGguY29tcGxldGUgPSB0cnVlXG4gICAgICAgICAgICAgICAgbGFzdEluY29tcGxldGVQYXRoLnBhdGggPSBwYXRoU2VnbWVudHMuam9pbignLicpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFzdEluY29tcGxldGVQYXRoLmludmFsaWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxhc3RJbmNvbXBsZXRlUGF0aC5jb21wbGV0ZSA9IHRydWVcbiAgICAgICAgICAgICAgbGFzdEluY29tcGxldGVQYXRoLnBhdGggPSBjdXJyZW50UGF0aFxuXG4gICAgICAgICAgICAgIGNvbnN0IG5lc3RlZFBhdGhUb1F1ZXJ5ID0gcGF0aFNlZ21lbnRzXG4gICAgICAgICAgICAgICAgLnNsaWNlKG5leHRTZWdtZW50SXNMb2NhbGUgPyBpICsgMiA6IGkgKyAxKVxuICAgICAgICAgICAgICAgIC5qb2luKCcuJylcblxuICAgICAgICAgICAgICBpZiAobmVzdGVkUGF0aFRvUXVlcnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWxhdGVkQ29sbGVjdGlvbiA9IHBheWxvYWQuY29sbGVjdGlvbnNbbWF0Y2hlZEZpZWxkLnJlbGF0aW9uVG9dLmNvbmZpZ1xuXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdQYXRocyA9IGF3YWl0IGdldExvY2FsaXplZFBhdGhzKHtcbiAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25TbHVnOiByZWxhdGVkQ29sbGVjdGlvbi5zbHVnLFxuICAgICAgICAgICAgICAgICAgZmllbGRzOiByZWxhdGVkQ29sbGVjdGlvbi5maWVsZHMsXG4gICAgICAgICAgICAgICAgICBnbG9iYWxTbHVnLFxuICAgICAgICAgICAgICAgICAgaW5jb21pbmdQYXRoOiBuZXN0ZWRQYXRoVG9RdWVyeSxcbiAgICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIHBhdGhzID0gWy4uLnBhdGhzLCAuLi5yZW1haW5pbmdQYXRoc11cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBwYXRoc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGlmICgnZmllbGRzJyBpbiBsYXN0SW5jb21wbGV0ZVBhdGguZmllbGQpIHtcbiAgICAgICAgICAgICAgbGFzdEluY29tcGxldGVQYXRoLmZpZWxkcyA9IGZsYXR0ZW5GaWVsZHMobGFzdEluY29tcGxldGVQYXRoLmZpZWxkLmZpZWxkcywgZmFsc2UpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpICsgMSA9PT0gcGF0aFNlZ21lbnRzLmxlbmd0aCkgbGFzdEluY29tcGxldGVQYXRoLmNvbXBsZXRlID0gdHJ1ZVxuICAgICAgICAgICAgbGFzdEluY29tcGxldGVQYXRoLnBhdGggPSBjdXJyZW50UGF0aFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdEluY29tcGxldGVQYXRoLmludmFsaWQgPSB0cnVlXG4gICAgICAgIGxhc3RJbmNvbXBsZXRlUGF0aC5wYXRoID0gY3VycmVudFBhdGhcbiAgICAgICAgcmV0dXJuIHBhdGhzXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdGhzXG59XG4iXSwibmFtZXMiOlsiZ2V0TG9jYWxpemVkUGF0aHMiLCJjb2xsZWN0aW9uU2x1ZyIsImZpZWxkcyIsImdsb2JhbFNsdWciLCJpbmNvbWluZ1BhdGgiLCJsb2NhbGUiLCJvdmVycmlkZUFjY2VzcyIsInBheWxvYWQiLCJwYXRoU2VnbWVudHMiLCJzcGxpdCIsImxvY2FsaXphdGlvbkNvbmZpZyIsImNvbmZpZyIsImxvY2FsaXphdGlvbiIsInBhdGhzIiwiY29tcGxldGUiLCJmaWVsZCIsInVuZGVmaW5lZCIsImZsYXR0ZW5GaWVsZHMiLCJpbnZhbGlkIiwicGF0aCIsImkiLCJsZW5ndGgiLCJzZWdtZW50IiwibGFzdEluY29tcGxldGVQYXRoIiwiZmluZCIsImN1cnJlbnRQYXRoIiwibWF0Y2hlZEZpZWxkIiwiZmllbGRBZmZlY3RzRGF0YSIsIm5hbWUiLCJ0eXBlIiwiaGlkZGVuIiwibmV4dFNlZ21lbnQiLCJuZXh0U2VnbWVudElzTG9jYWxlIiwibG9jYWxlQ29kZXMiLCJpbmNsdWRlcyIsImxvY2FsaXplZCIsInVwY29taW5nU2VnbWVudHMiLCJzbGljZSIsImpvaW4iLCJyZWxhdGlvblRvIiwibGFzdFNlZ21lbnRJc1ZhbGlkIiwibmVzdGVkUGF0aFRvUXVlcnkiLCJyZWxhdGVkQ29sbGVjdGlvbiIsImNvbGxlY3Rpb25zIiwicmVtYWluaW5nUGF0aHMiLCJzbHVnIl0sIm1hcHBpbmdzIjoiOzs7OytCQU9zQkE7OztlQUFBQTs7O3VCQUhXOzhFQUNQOzs7Ozs7QUFFbkIsZUFBZUEsa0JBQWtCLEVBQ3RDQyxjQUFjLEVBQ2RDLE1BQU0sRUFDTkMsVUFBVSxFQUNWQyxZQUFZLEVBQ1pDLE1BQU0sRUFDTkMsaUJBQWlCLEtBQUssRUFDdEJDLE9BQU8sRUFTUjtJQUNDLE1BQU1DLGVBQWVKLGFBQWFLLEtBQUssQ0FBQztJQUN4QyxNQUFNQyxxQkFBcUJILFFBQVFJLE1BQU0sQ0FBQ0MsWUFBWTtJQUV0RCxJQUFJQyxRQUF1QjtRQUN6QjtZQUNFWjtZQUNBYSxVQUFVO1lBQ1ZDLE9BQU9DO1lBQ1BkLFFBQVFlLElBQUFBLDhCQUFhLEVBQUNmLFFBQVE7WUFDOUJDO1lBQ0FlLFNBQVM7WUFDVEMsTUFBTTtRQUNSO0tBQ0Q7SUFFRCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVosYUFBYWEsTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDL0MsTUFBTUUsVUFBVWQsWUFBWSxDQUFDWSxFQUFFO1FBRS9CLE1BQU1HLHFCQUFxQlYsTUFBTVcsSUFBSSxDQUFDLENBQUMsRUFBRVYsUUFBUSxFQUFFLEdBQUssQ0FBQ0E7UUFFekQsSUFBSVMsb0JBQW9CO1lBQ3RCLE1BQU0sRUFBRUosSUFBSSxFQUFFLEdBQUdJ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